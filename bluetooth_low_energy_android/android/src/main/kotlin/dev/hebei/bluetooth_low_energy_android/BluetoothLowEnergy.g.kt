// Autogenerated from Pigeon (v24.2.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package dev.hebei.bluetooth_low_energy_android

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is BluetoothLowEnergyError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): BluetoothLowEnergyError {
  return BluetoothLowEnergyError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class BluetoothLowEnergyError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()
/**
 * Maintains instances used to communicate with the corresponding objects in Dart.
 *
 * Objects stored in this container are represented by an object in Dart that is also stored in
 * an InstanceManager with the same identifier.
 *
 * When an instance is added with an identifier, either can be used to retrieve the other.
 *
 * Added instances are added as a weak reference and a strong reference. When the strong
 * reference is removed with [remove] and the weak reference is deallocated, the
 * `finalizationListener.onFinalize` is called with the instance's identifier. However, if the strong
 * reference is removed and then the identifier is retrieved with the intention to pass the identifier
 * to Dart (e.g. calling [getIdentifierForStrongReference]), the strong reference to the instance
 * is recreated. The strong reference will then need to be removed manually again.
 */
@Suppress("UNCHECKED_CAST", "MemberVisibilityCanBePrivate")
class BluetoothLowEnergyPigeonInstanceManager(private val finalizationListener: PigeonFinalizationListener) {
  /** Interface for listening when a weak reference of an instance is removed from the manager.  */
  interface PigeonFinalizationListener {
    fun onFinalize(identifier: Long)
  }

  private val identifiers = java.util.WeakHashMap<Any, Long>()
  private val weakInstances = HashMap<Long, java.lang.ref.WeakReference<Any>>()
  private val strongInstances = HashMap<Long, Any>()
  private val referenceQueue = java.lang.ref.ReferenceQueue<Any>()
  private val weakReferencesToIdentifiers = HashMap<java.lang.ref.WeakReference<Any>, Long>()
  private val handler = android.os.Handler(android.os.Looper.getMainLooper())
  private var nextIdentifier: Long = minHostCreatedIdentifier
  private var hasFinalizationListenerStopped = false

  /**
   * Modifies the time interval used to define how often this instance removes garbage collected
   * weak references to native Android objects that this instance was managing.
   */
  var clearFinalizedWeakReferencesInterval: Long = 3000
    set(value) {
      handler.removeCallbacks { this.releaseAllFinalizedInstances() }
      field = value
      releaseAllFinalizedInstances()
    }

  init {
    handler.postDelayed(
      { releaseAllFinalizedInstances() },
      clearFinalizedWeakReferencesInterval
    )
  }

  companion object {
    // Identifiers are locked to a specific range to avoid collisions with objects
    // created simultaneously from Dart.
    // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
    // 0 <= n < 2^16.
    private const val minHostCreatedIdentifier: Long = 65536
    private const val tag = "PigeonInstanceManager"

    /**
     * Instantiate a new manager with a listener for garbage collected weak
     * references.
     *
     * When the manager is no longer needed, [stopFinalizationListener] must be called.
     */
    fun create(finalizationListener: PigeonFinalizationListener): BluetoothLowEnergyPigeonInstanceManager {
      return BluetoothLowEnergyPigeonInstanceManager(finalizationListener)
    }
  }

  /**
   * Removes `identifier` and return its associated strongly referenced instance, if present,
   * from the manager.
   */
  fun <T> remove(identifier: Long): T? {
    logWarningIfFinalizationListenerHasStopped()
    return strongInstances.remove(identifier) as T?
  }

  /**
   * Retrieves the identifier paired with an instance, if present, otherwise `null`.
   *
   *
   * If the manager contains a strong reference to `instance`, it will return the identifier
   * associated with `instance`. If the manager contains only a weak reference to `instance`, a new
   * strong reference to `instance` will be added and will need to be removed again with [remove].
   *
   *
   * If this method returns a nonnull identifier, this method also expects the Dart
   * `BluetoothLowEnergyPigeonInstanceManager` to have, or recreate, a weak reference to the Dart instance the
   * identifier is associated with.
   */
  fun getIdentifierForStrongReference(instance: Any?): Long? {
    logWarningIfFinalizationListenerHasStopped()
    val identifier = identifiers[instance]
    if (identifier != null) {
      strongInstances[identifier] = instance!!
    }
    return identifier
  }

  /**
   * Adds a new instance that was instantiated from Dart.
   *
   * The same instance can be added multiple times, but each identifier must be unique. This
   * allows two objects that are equivalent (e.g. the `equals` method returns true and their
   * hashcodes are equal) to both be added.
   *
   * [identifier] must be >= 0 and unique.
   */
  fun addDartCreatedInstance(instance: Any, identifier: Long) {
    logWarningIfFinalizationListenerHasStopped()
    addInstance(instance, identifier)
  }

  /**
   * Adds a new unique instance that was instantiated from the host platform.
   *
   * [identifier] must be >= 0 and unique.
   */
  fun addHostCreatedInstance(instance: Any): Long {
    logWarningIfFinalizationListenerHasStopped()
    require(!containsInstance(instance)) { "Instance of ${instance.javaClass} has already been added." }
    val identifier = nextIdentifier++
    addInstance(instance, identifier)
    return identifier
  }

  /** Retrieves the instance associated with identifier, if present, otherwise `null`. */
  fun <T> getInstance(identifier: Long): T? {
    logWarningIfFinalizationListenerHasStopped()
    val instance = weakInstances[identifier] as java.lang.ref.WeakReference<T>?
    return instance?.get()
  }

  /** Returns whether this manager contains the given `instance`. */
  fun containsInstance(instance: Any?): Boolean {
    logWarningIfFinalizationListenerHasStopped()
    return identifiers.containsKey(instance)
  }

  /**
   * Stops the periodic run of the [PigeonFinalizationListener] for instances that have been garbage
   * collected.
   *
   * The InstanceManager can continue to be used, but the [PigeonFinalizationListener] will no
   * longer be called and methods will log a warning.
   */
  fun stopFinalizationListener() {
    handler.removeCallbacks { this.releaseAllFinalizedInstances() }
    hasFinalizationListenerStopped = true
  }

  /**
   * Removes all of the instances from this manager.
   *
   * The manager will be empty after this call returns.
   */
  fun clear() {
    identifiers.clear()
    weakInstances.clear()
    strongInstances.clear()
    weakReferencesToIdentifiers.clear()
  }

  /**
   * Whether the [PigeonFinalizationListener] is still being called for instances that are garbage
   * collected.
   *
   * See [stopFinalizationListener].
   */
  fun hasFinalizationListenerStopped(): Boolean {
    return hasFinalizationListenerStopped
  }

  private fun releaseAllFinalizedInstances() {
    if (hasFinalizationListenerStopped()) {
      return
    }
    var reference: java.lang.ref.WeakReference<Any>?
    while ((referenceQueue.poll() as java.lang.ref.WeakReference<Any>?).also { reference = it } != null) {
      val identifier = weakReferencesToIdentifiers.remove(reference)
      if (identifier != null) {
        weakInstances.remove(identifier)
        strongInstances.remove(identifier)
        finalizationListener.onFinalize(identifier)
      }
    }
    handler.postDelayed(
      { releaseAllFinalizedInstances() },
      clearFinalizedWeakReferencesInterval
    )
  }

  private fun addInstance(instance: Any, identifier: Long) {
    require(identifier >= 0) { "Identifier must be >= 0: $identifier" }
    require(!weakInstances.containsKey(identifier)) {
      "Identifier has already been added: $identifier"
    }
    val weakReference = java.lang.ref.WeakReference(instance, referenceQueue)
    identifiers[instance] = identifier
    weakInstances[identifier] = weakReference
    weakReferencesToIdentifiers[weakReference] = identifier
    strongInstances[identifier] = instance
  }

  private fun logWarningIfFinalizationListenerHasStopped() {
    if (hasFinalizationListenerStopped()) {
      Log.w(
        tag,
        "The manager was used after calls to the PigeonFinalizationListener has been stopped."
      )
    }
  }
}


/** Generated API for managing the Dart and native `InstanceManager`s. */
private class BluetoothLowEnergyPigeonInstanceManagerApi(val binaryMessenger: BinaryMessenger) {
  companion object {
    /** The codec used by BluetoothLowEnergyPigeonInstanceManagerApi. */
    val codec: MessageCodec<Any?> by lazy {
      BluetoothLowEnergyPigeonCodec()
    }

    /**
     * Sets up an instance of `BluetoothLowEnergyPigeonInstanceManagerApi` to handle messages from the
     * `binaryMessenger`.
     */
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, instanceManager: BluetoothLowEnergyPigeonInstanceManager?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.PigeonInternalInstanceManager.removeStrongReference", codec)
        if (instanceManager != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              instanceManager.remove<Any?>(identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.PigeonInternalInstanceManager.clear", codec)
        if (instanceManager != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              instanceManager.clear()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  fun removeStrongReference(identifierArg: Long, callback: (Result<Unit>) -> Unit)
{
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.PigeonInternalInstanceManager.removeStrongReference"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(identifierArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/**
 * Provides implementations for each ProxyApi implementation and provides access to resources
 * needed by any implementation.
 */
abstract class BluetoothLowEnergyPigeonProxyApiRegistrar(val binaryMessenger: BinaryMessenger) {
  /** Whether APIs should ignore calling to Dart. */
  public var ignoreCallsToDart = false
  val instanceManager: BluetoothLowEnergyPigeonInstanceManager
  private var _codec: MessageCodec<Any?>? = null
  val codec: MessageCodec<Any?>
    get() {
      if (_codec == null) {
        _codec = BluetoothLowEnergyPigeonProxyApiBaseCodec(this)
      }
      return _codec!!
    }

  init {
    val api = BluetoothLowEnergyPigeonInstanceManagerApi(binaryMessenger)
    instanceManager = BluetoothLowEnergyPigeonInstanceManager.create(
      object : BluetoothLowEnergyPigeonInstanceManager.PigeonFinalizationListener {
        override fun onFinalize(identifier: Long) {
          api.removeStrongReference(identifier) {
            if (it.isFailure) {
              Log.e(
                "PigeonProxyApiRegistrar",
                "Failed to remove Dart strong reference with identifier: $identifier"
              )
            }
          }
        }
      }
    )
  }
  /**
   * An implementation of [PigeonApiBluetoothLowEnergyAndroidPlugin] used to add a new Dart instance of
   * `BluetoothLowEnergyAndroidPlugin` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothLowEnergyAndroidPlugin(): PigeonApiBluetoothLowEnergyAndroidPlugin

  /**
   * An implementation of [PigeonApiRequestPermissionsResultListener] used to add a new Dart instance of
   * `RequestPermissionsResultListener` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiRequestPermissionsResultListener(): PigeonApiRequestPermissionsResultListener
  {
    return PigeonApiRequestPermissionsResultListener(this)
  }

  /**
   * An implementation of [PigeonApiActivityResultListener] used to add a new Dart instance of
   * `ActivityResultListener` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiActivityResultListener(): PigeonApiActivityResultListener
  {
    return PigeonApiActivityResultListener(this)
  }

  /**
   * An implementation of [PigeonApiAny] used to add a new Dart instance of
   * `Any` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAny(): PigeonApiAny

  /**
   * An implementation of [PigeonApiActivity] used to add a new Dart instance of
   * `Activity` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiActivity(): PigeonApiActivity
  {
    return PigeonApiActivity(this)
  }

  /**
   * An implementation of [PigeonApiPendingIntent] used to add a new Dart instance of
   * `PendingIntent` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiPendingIntent(): PigeonApiPendingIntent
  {
    return PigeonApiPendingIntent(this)
  }

  /**
   * An implementation of [PigeonApiBluetoothAdapter] used to add a new Dart instance of
   * `BluetoothAdapter` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothAdapter(): PigeonApiBluetoothAdapter

  /**
   * An implementation of [PigeonApiBluetoothClass] used to add a new Dart instance of
   * `BluetoothClass` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothClass(): PigeonApiBluetoothClass

  /**
   * An implementation of [PigeonApiBluetoothDevice] used to add a new Dart instance of
   * `BluetoothDevice` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothDevice(): PigeonApiBluetoothDevice

  /**
   * An implementation of [PigeonApiBluetoothGatt] used to add a new Dart instance of
   * `BluetoothGatt` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothGatt(): PigeonApiBluetoothGatt

  /**
   * An implementation of [PigeonApiBluetoothGattCallback] used to add a new Dart instance of
   * `BluetoothGattCallback` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothGattCallback(): PigeonApiBluetoothGattCallback

  /**
   * An implementation of [PigeonApiBluetoothGattCharacteristic] used to add a new Dart instance of
   * `BluetoothGattCharacteristic` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothGattCharacteristic(): PigeonApiBluetoothGattCharacteristic

  /**
   * An implementation of [PigeonApiBluetoothGattDescriptor] used to add a new Dart instance of
   * `BluetoothGattDescriptor` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothGattDescriptor(): PigeonApiBluetoothGattDescriptor

  /**
   * An implementation of [PigeonApiBluetoothGattServer] used to add a new Dart instance of
   * `BluetoothGattServer` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothGattServer(): PigeonApiBluetoothGattServer

  /**
   * An implementation of [PigeonApiBluetoothGattServerCallback] used to add a new Dart instance of
   * `BluetoothGattServerCallback` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothGattServerCallback(): PigeonApiBluetoothGattServerCallback

  /**
   * An implementation of [PigeonApiBluetoothGattService] used to add a new Dart instance of
   * `BluetoothGattService` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothGattService(): PigeonApiBluetoothGattService

  /**
   * An implementation of [PigeonApiBluetoothManager] used to add a new Dart instance of
   * `BluetoothManager` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothManager(): PigeonApiBluetoothManager

  /**
   * An implementation of [PigeonApiBluetoothServerSocket] used to add a new Dart instance of
   * `BluetoothServerSocket` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothServerSocket(): PigeonApiBluetoothServerSocket

  /**
   * An implementation of [PigeonApiBluetoothSocket] used to add a new Dart instance of
   * `BluetoothSocket` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothSocket(): PigeonApiBluetoothSocket

  /**
   * An implementation of [PigeonApiLeScanCallback] used to add a new Dart instance of
   * `LeScanCallback` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiLeScanCallback(): PigeonApiLeScanCallback

  /**
   * An implementation of [PigeonApiBluetoothProfile] used to add a new Dart instance of
   * `BluetoothProfile` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothProfile(): PigeonApiBluetoothProfile

  /**
   * An implementation of [PigeonApiServiceListener] used to add a new Dart instance of
   * `ServiceListener` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiServiceListener(): PigeonApiServiceListener

  /**
   * An implementation of [PigeonApiAdvertiseCallback] used to add a new Dart instance of
   * `AdvertiseCallback` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertiseCallback(): PigeonApiAdvertiseCallback

  /**
   * An implementation of [PigeonApiAdvertiseData] used to add a new Dart instance of
   * `AdvertiseData` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertiseData(): PigeonApiAdvertiseData

  /**
   * An implementation of [PigeonApiAdvertiseDataBuilder] used to add a new Dart instance of
   * `AdvertiseDataBuilder` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertiseDataBuilder(): PigeonApiAdvertiseDataBuilder

  /**
   * An implementation of [PigeonApiAdvertiseSettings] used to add a new Dart instance of
   * `AdvertiseSettings` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertiseSettings(): PigeonApiAdvertiseSettings

  /**
   * An implementation of [PigeonApiAdvertiseSettingsBuilder] used to add a new Dart instance of
   * `AdvertiseSettingsBuilder` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertiseSettingsBuilder(): PigeonApiAdvertiseSettingsBuilder

  /**
   * An implementation of [PigeonApiAdvertisingSet] used to add a new Dart instance of
   * `AdvertisingSet` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertisingSet(): PigeonApiAdvertisingSet

  /**
   * An implementation of [PigeonApiAdvertisingSetCallback] used to add a new Dart instance of
   * `AdvertisingSetCallback` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertisingSetCallback(): PigeonApiAdvertisingSetCallback

  /**
   * An implementation of [PigeonApiAdvertisingSetParameters] used to add a new Dart instance of
   * `AdvertisingSetParameters` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertisingSetParameters(): PigeonApiAdvertisingSetParameters

  /**
   * An implementation of [PigeonApiAdvertisingSetParametersBuilder] used to add a new Dart instance of
   * `AdvertisingSetParametersBuilder` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiAdvertisingSetParametersBuilder(): PigeonApiAdvertisingSetParametersBuilder

  /**
   * An implementation of [PigeonApiBluetoothLeAdvertiser] used to add a new Dart instance of
   * `BluetoothLeAdvertiser` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothLeAdvertiser(): PigeonApiBluetoothLeAdvertiser

  /**
   * An implementation of [PigeonApiBluetoothLeScanner] used to add a new Dart instance of
   * `BluetoothLeScanner` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiBluetoothLeScanner(): PigeonApiBluetoothLeScanner

  /**
   * An implementation of [PigeonApiPeriodicAdvertisingParameters] used to add a new Dart instance of
   * `PeriodicAdvertisingParameters` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiPeriodicAdvertisingParameters(): PigeonApiPeriodicAdvertisingParameters

  /**
   * An implementation of [PigeonApiPeriodicAdvertisingParametersBuilder] used to add a new Dart instance of
   * `PeriodicAdvertisingParametersBuilder` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiPeriodicAdvertisingParametersBuilder(): PigeonApiPeriodicAdvertisingParametersBuilder

  /**
   * An implementation of [PigeonApiScanCallback] used to add a new Dart instance of
   * `ScanCallback` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiScanCallback(): PigeonApiScanCallback

  /**
   * An implementation of [PigeonApiScanFilter] used to add a new Dart instance of
   * `ScanFilter` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiScanFilter(): PigeonApiScanFilter

  /**
   * An implementation of [PigeonApiScanFilterBuilder] used to add a new Dart instance of
   * `ScanFilterBuilder` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiScanFilterBuilder(): PigeonApiScanFilterBuilder

  /**
   * An implementation of [PigeonApiScanRecord] used to add a new Dart instance of
   * `ScanRecord` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiScanRecord(): PigeonApiScanRecord

  /**
   * An implementation of [PigeonApiScanResult] used to add a new Dart instance of
   * `ScanResult` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiScanResult(): PigeonApiScanResult

  /**
   * An implementation of [PigeonApiScanSettings] used to add a new Dart instance of
   * `ScanSettings` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiScanSettings(): PigeonApiScanSettings

  /**
   * An implementation of [PigeonApiScanSettingsBuilder] used to add a new Dart instance of
   * `ScanSettingsBuilder` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiScanSettingsBuilder(): PigeonApiScanSettingsBuilder

  /**
   * An implementation of [PigeonApiTransportBlock] used to add a new Dart instance of
   * `TransportBlock` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiTransportBlock(): PigeonApiTransportBlock
  {
    return PigeonApiTransportBlock(this)
  }

  /**
   * An implementation of [PigeonApiTransportDiscoveryData] used to add a new Dart instance of
   * `TransportDiscoveryData` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiTransportDiscoveryData(): PigeonApiTransportDiscoveryData
  {
    return PigeonApiTransportDiscoveryData(this)
  }

  /**
   * An implementation of [PigeonApiContext] used to add a new Dart instance of
   * `Context` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiContext(): PigeonApiContext
  {
    return PigeonApiContext(this)
  }

  /**
   * An implementation of [PigeonApiIntent] used to add a new Dart instance of
   * `Intent` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiIntent(): PigeonApiIntent
  {
    return PigeonApiIntent(this)
  }

  /**
   * An implementation of [PigeonApiHandler] used to add a new Dart instance of
   * `Handler` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiHandler(): PigeonApiHandler
  {
    return PigeonApiHandler(this)
  }

  /**
   * An implementation of [PigeonApiParcelUuid] used to add a new Dart instance of
   * `ParcelUuid` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiParcelUuid(): PigeonApiParcelUuid

  /**
   * An implementation of [PigeonApiInputStream] used to add a new Dart instance of
   * `InputStream` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiInputStream(): PigeonApiInputStream
  {
    return PigeonApiInputStream(this)
  }

  /**
   * An implementation of [PigeonApiOutputStream] used to add a new Dart instance of
   * `OutputStream` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiOutputStream(): PigeonApiOutputStream
  {
    return PigeonApiOutputStream(this)
  }

  /**
   * An implementation of [PigeonApiDuration] used to add a new Dart instance of
   * `Duration` to the Dart `InstanceManager`.
   */
  open fun getPigeonApiDuration(): PigeonApiDuration
  {
    return PigeonApiDuration(this)
  }

  /**
   * An implementation of [PigeonApiUUID] used to add a new Dart instance of
   * `UUID` to the Dart `InstanceManager`.
   */
  abstract fun getPigeonApiUUID(): PigeonApiUUID

  fun setUp() {
    BluetoothLowEnergyPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger, instanceManager)
    PigeonApiBluetoothLowEnergyAndroidPlugin.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothLowEnergyAndroidPlugin())
    PigeonApiAny.setUpMessageHandlers(binaryMessenger, getPigeonApiAny())
    PigeonApiBluetoothAdapter.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothAdapter())
    PigeonApiBluetoothClass.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothClass())
    PigeonApiBluetoothDevice.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothDevice())
    PigeonApiBluetoothGatt.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothGatt())
    PigeonApiBluetoothGattCallback.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothGattCallback())
    PigeonApiBluetoothGattCharacteristic.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothGattCharacteristic())
    PigeonApiBluetoothGattDescriptor.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothGattDescriptor())
    PigeonApiBluetoothGattServer.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothGattServer())
    PigeonApiBluetoothGattServerCallback.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothGattServerCallback())
    PigeonApiBluetoothGattService.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothGattService())
    PigeonApiBluetoothManager.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothManager())
    PigeonApiBluetoothServerSocket.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothServerSocket())
    PigeonApiBluetoothSocket.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothSocket())
    PigeonApiLeScanCallback.setUpMessageHandlers(binaryMessenger, getPigeonApiLeScanCallback())
    PigeonApiBluetoothProfile.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothProfile())
    PigeonApiServiceListener.setUpMessageHandlers(binaryMessenger, getPigeonApiServiceListener())
    PigeonApiAdvertiseCallback.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertiseCallback())
    PigeonApiAdvertiseData.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertiseData())
    PigeonApiAdvertiseDataBuilder.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertiseDataBuilder())
    PigeonApiAdvertiseSettings.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertiseSettings())
    PigeonApiAdvertiseSettingsBuilder.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertiseSettingsBuilder())
    PigeonApiAdvertisingSet.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertisingSet())
    PigeonApiAdvertisingSetCallback.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertisingSetCallback())
    PigeonApiAdvertisingSetParameters.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertisingSetParameters())
    PigeonApiAdvertisingSetParametersBuilder.setUpMessageHandlers(binaryMessenger, getPigeonApiAdvertisingSetParametersBuilder())
    PigeonApiBluetoothLeAdvertiser.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothLeAdvertiser())
    PigeonApiBluetoothLeScanner.setUpMessageHandlers(binaryMessenger, getPigeonApiBluetoothLeScanner())
    PigeonApiPeriodicAdvertisingParameters.setUpMessageHandlers(binaryMessenger, getPigeonApiPeriodicAdvertisingParameters())
    PigeonApiPeriodicAdvertisingParametersBuilder.setUpMessageHandlers(binaryMessenger, getPigeonApiPeriodicAdvertisingParametersBuilder())
    PigeonApiScanCallback.setUpMessageHandlers(binaryMessenger, getPigeonApiScanCallback())
    PigeonApiScanFilter.setUpMessageHandlers(binaryMessenger, getPigeonApiScanFilter())
    PigeonApiScanFilterBuilder.setUpMessageHandlers(binaryMessenger, getPigeonApiScanFilterBuilder())
    PigeonApiScanRecord.setUpMessageHandlers(binaryMessenger, getPigeonApiScanRecord())
    PigeonApiScanResult.setUpMessageHandlers(binaryMessenger, getPigeonApiScanResult())
    PigeonApiScanSettings.setUpMessageHandlers(binaryMessenger, getPigeonApiScanSettings())
    PigeonApiScanSettingsBuilder.setUpMessageHandlers(binaryMessenger, getPigeonApiScanSettingsBuilder())
    PigeonApiParcelUuid.setUpMessageHandlers(binaryMessenger, getPigeonApiParcelUuid())
    PigeonApiUUID.setUpMessageHandlers(binaryMessenger, getPigeonApiUUID())
  }
  fun tearDown() {
    BluetoothLowEnergyPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothLowEnergyAndroidPlugin.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAny.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothAdapter.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothClass.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothDevice.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothGatt.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothGattCallback.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothGattCharacteristic.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothGattDescriptor.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothGattServer.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothGattServerCallback.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothGattService.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothManager.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothServerSocket.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothSocket.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiLeScanCallback.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothProfile.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiServiceListener.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertiseCallback.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertiseData.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertiseDataBuilder.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertiseSettings.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertiseSettingsBuilder.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertisingSet.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertisingSetCallback.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertisingSetParameters.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiAdvertisingSetParametersBuilder.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothLeAdvertiser.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiBluetoothLeScanner.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiPeriodicAdvertisingParameters.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiPeriodicAdvertisingParametersBuilder.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiScanCallback.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiScanFilter.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiScanFilterBuilder.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiScanRecord.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiScanResult.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiScanSettings.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiScanSettingsBuilder.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiParcelUuid.setUpMessageHandlers(binaryMessenger, null)
    PigeonApiUUID.setUpMessageHandlers(binaryMessenger, null)
  }
}
private class BluetoothLowEnergyPigeonProxyApiBaseCodec(val registrar: BluetoothLowEnergyPigeonProxyApiRegistrar) : BluetoothLowEnergyPigeonCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        val identifier: Long = readValue(buffer) as Long
        val instance: Any? = registrar.instanceManager.getInstance(identifier)
        if (instance == null) {
          Log.e(
            "PigeonProxyApiBaseCodec",
            "Failed to find instance with identifier: $identifier"
          )
        }
        return instance
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    if (value is Boolean || value is ByteArray || value is Double || value is DoubleArray || value is FloatArray || value is Int || value is IntArray || value is List<*> || value is Long || value is LongArray || value is Map<*, *> || value is String || value is BluetoothStatusCodes || value == null) {
      super.writeValue(stream, value)
      return
    }

    if (value is dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin) {
      registrar.getPigeonApiBluetoothLowEnergyAndroidPlugin().pigeon_newInstance(value) { }
    }
     else if (value is io.flutter.plugin.common.PluginRegistry.RequestPermissionsResultListener) {
      registrar.getPigeonApiRequestPermissionsResultListener().pigeon_newInstance(value) { }
    }
     else if (value is io.flutter.plugin.common.PluginRegistry.ActivityResultListener) {
      registrar.getPigeonApiActivityResultListener().pigeon_newInstance(value) { }
    }
     else if (value is android.app.Activity) {
      registrar.getPigeonApiActivity().pigeon_newInstance(value) { }
    }
     else if (value is android.app.PendingIntent) {
      registrar.getPigeonApiPendingIntent().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothAdapter) {
      registrar.getPigeonApiBluetoothAdapter().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothClass) {
      registrar.getPigeonApiBluetoothClass().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothDevice) {
      registrar.getPigeonApiBluetoothDevice().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothGatt) {
      registrar.getPigeonApiBluetoothGatt().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothGattCallback) {
      registrar.getPigeonApiBluetoothGattCallback().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothGattCharacteristic) {
      registrar.getPigeonApiBluetoothGattCharacteristic().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothGattDescriptor) {
      registrar.getPigeonApiBluetoothGattDescriptor().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothGattServer) {
      registrar.getPigeonApiBluetoothGattServer().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothGattServerCallback) {
      registrar.getPigeonApiBluetoothGattServerCallback().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothGattService) {
      registrar.getPigeonApiBluetoothGattService().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothManager) {
      registrar.getPigeonApiBluetoothManager().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothServerSocket) {
      registrar.getPigeonApiBluetoothServerSocket().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothSocket) {
      registrar.getPigeonApiBluetoothSocket().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothAdapter.LeScanCallback) {
      registrar.getPigeonApiLeScanCallback().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothProfile) {
      registrar.getPigeonApiBluetoothProfile().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.BluetoothProfile.ServiceListener) {
      registrar.getPigeonApiServiceListener().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.AdvertiseCallback) {
      registrar.getPigeonApiAdvertiseCallback().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.AdvertiseData) {
      registrar.getPigeonApiAdvertiseData().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.AdvertiseData.Builder) {
      registrar.getPigeonApiAdvertiseDataBuilder().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.AdvertiseSettings) {
      registrar.getPigeonApiAdvertiseSettings().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.AdvertiseSettings.Builder) {
      registrar.getPigeonApiAdvertiseSettingsBuilder().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 26 && value is android.bluetooth.le.AdvertisingSet) {
      registrar.getPigeonApiAdvertisingSet().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 26 && value is android.bluetooth.le.AdvertisingSetCallback) {
      registrar.getPigeonApiAdvertisingSetCallback().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 26 && value is android.bluetooth.le.AdvertisingSetParameters) {
      registrar.getPigeonApiAdvertisingSetParameters().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 26 && value is android.bluetooth.le.AdvertisingSetParameters.Builder) {
      registrar.getPigeonApiAdvertisingSetParametersBuilder().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.BluetoothLeAdvertiser) {
      registrar.getPigeonApiBluetoothLeAdvertiser().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.BluetoothLeScanner) {
      registrar.getPigeonApiBluetoothLeScanner().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 26 && value is android.bluetooth.le.PeriodicAdvertisingParameters) {
      registrar.getPigeonApiPeriodicAdvertisingParameters().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 26 && value is android.bluetooth.le.PeriodicAdvertisingParameters.Builder) {
      registrar.getPigeonApiPeriodicAdvertisingParametersBuilder().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.ScanCallback) {
      registrar.getPigeonApiScanCallback().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.ScanFilter) {
      registrar.getPigeonApiScanFilter().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.ScanFilter.Builder) {
      registrar.getPigeonApiScanFilterBuilder().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.ScanRecord) {
      registrar.getPigeonApiScanRecord().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.ScanResult) {
      registrar.getPigeonApiScanResult().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.ScanSettings) {
      registrar.getPigeonApiScanSettings().pigeon_newInstance(value) { }
    }
     else if (value is android.bluetooth.le.ScanSettings.Builder) {
      registrar.getPigeonApiScanSettingsBuilder().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 33 && value is android.bluetooth.le.TransportBlock) {
      registrar.getPigeonApiTransportBlock().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 33 && value is android.bluetooth.le.TransportDiscoveryData) {
      registrar.getPigeonApiTransportDiscoveryData().pigeon_newInstance(value) { }
    }
     else if (value is android.content.Context) {
      registrar.getPigeonApiContext().pigeon_newInstance(value) { }
    }
     else if (value is android.content.Intent) {
      registrar.getPigeonApiIntent().pigeon_newInstance(value) { }
    }
     else if (value is android.os.Handler) {
      registrar.getPigeonApiHandler().pigeon_newInstance(value) { }
    }
     else if (value is android.os.ParcelUuid) {
      registrar.getPigeonApiParcelUuid().pigeon_newInstance(value) { }
    }
     else if (value is java.io.InputStream) {
      registrar.getPigeonApiInputStream().pigeon_newInstance(value) { }
    }
     else if (value is java.io.OutputStream) {
      registrar.getPigeonApiOutputStream().pigeon_newInstance(value) { }
    }
     else if (android.os.Build.VERSION.SDK_INT >= 26 && value is java.time.Duration) {
      registrar.getPigeonApiDuration().pigeon_newInstance(value) { }
    }
     else if (value is java.util.UUID) {
      registrar.getPigeonApiUUID().pigeon_newInstance(value) { }
    }
     else if (value is Any) {
      registrar.getPigeonApiAny().pigeon_newInstance(value) { }
    }

    when {
      registrar.instanceManager.containsInstance(value) -> {
        stream.write(128)
        writeValue(stream, registrar.instanceManager.getIdentifierForStrongReference(value))
      }
      else -> throw IllegalArgumentException("Unsupported value: '$value' of type '${value.javaClass.name}'")
    }
  }
}

/**
 * A class with constants representing possible return values for Bluetooth APIs.
 * General return values occupy the range 0 to 199. Profile-specific return values
 * occupy the range 200-999. API-specific return values start at 1000. The
 * exception to this is the "UNKNOWN" error code which occupies the max integer
 * value.
 */
enum class BluetoothStatusCodes(val raw: Int) {
  /**
   * Error code indicating that the API call was initiated by neither the system
   * nor the active user.
   */
  ERROR_BLUETOOTH_NOT_ALLOWED(0),
  /** Error code indicating that Bluetooth is not enabled. */
  ERROR_BLUETOOTH_NOT_ENABLED(1),
  /** Error code indicating that the Bluetooth Device specified is not bonded. */
  ERROR_DEVICE_NOT_BONDED(2),
  /** A GATT writeCharacteristic request is not permitted on the remote device. */
  ERROR_GATT_WRITE_NOT_ALLOWED(3),
  /** A GATT writeCharacteristic request is issued to a busy remote device. */
  ERROR_GATT_WRITE_REQUEST_BUSY(4),
  /**
   * Error code indicating that the caller does not have the
   * android.Manifest.permission#BLUETOOTH_CONNECT permission.
   */
  ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION(5),
  /**
   * Error code indicating that the profile service is not bound. You can bind
   * a profile service by calling BluetoothAdapter.getProfileProxy.
   */
  ERROR_PROFILE_SERVICE_NOT_BOUND(6),
  /** Indicates that an unknown error has occurred. */
  ERROR_UNKNOWN(7),
  /** Indicates that the feature status is not configured yet. */
  FEATURE_NOT_CONFIGURED(8),
  /** Indicates that the feature is not supported. */
  FEATURE_NOT_SUPPORTED(9),
  /** Indicates that the feature is supported. */
  FEATURE_SUPPORTED(10),
  /** Indicates that the API call was successful. */
  SUCCESS(11);

  companion object {
    fun ofRaw(raw: Int): BluetoothStatusCodes? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}
private open class BluetoothLowEnergyPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          BluetoothStatusCodes.ofRaw(it.toInt())
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is BluetoothStatusCodes -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      else -> super.writeValue(stream, value)
    }
  }
}

@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothLowEnergyAndroidPlugin(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun instance(): dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin

  abstract fun applicationContext(pigeon_instance: dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin): android.content.Context

  abstract fun getActivity(pigeon_instance: dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin): android.app.Activity?

  abstract fun addRequestPermissionsResultListener(pigeon_instance: dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin, listener: io.flutter.plugin.common.PluginRegistry.RequestPermissionsResultListener)

  abstract fun removeRequestPermissionsResultListener(pigeon_instance: dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin, listener: io.flutter.plugin.common.PluginRegistry.RequestPermissionsResultListener)

  abstract fun addActivityResultListener(pigeon_instance: dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin, listener: io.flutter.plugin.common.PluginRegistry.ActivityResultListener)

  abstract fun removeActivityResultListener(pigeon_instance: dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin, listener: io.flutter.plugin.common.PluginRegistry.ActivityResultListener)

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothLowEnergyAndroidPlugin?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin.instance", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.instance(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin.applicationContext", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin
            val pigeon_identifierArg = args[1] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.applicationContext(pigeon_instanceArg), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin.getActivity", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin
            val wrapped: List<Any?> = try {
              listOf(api.getActivity(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin.addRequestPermissionsResultListener", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin
            val listenerArg = args[1] as io.flutter.plugin.common.PluginRegistry.RequestPermissionsResultListener
            val wrapped: List<Any?> = try {
              api.addRequestPermissionsResultListener(pigeon_instanceArg, listenerArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin.removeRequestPermissionsResultListener", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin
            val listenerArg = args[1] as io.flutter.plugin.common.PluginRegistry.RequestPermissionsResultListener
            val wrapped: List<Any?> = try {
              api.removeRequestPermissionsResultListener(pigeon_instanceArg, listenerArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin.addActivityResultListener", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin
            val listenerArg = args[1] as io.flutter.plugin.common.PluginRegistry.ActivityResultListener
            val wrapped: List<Any?> = try {
              api.addActivityResultListener(pigeon_instanceArg, listenerArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin.removeActivityResultListener", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin
            val listenerArg = args[1] as io.flutter.plugin.common.PluginRegistry.ActivityResultListener
            val wrapped: List<Any?> = try {
              api.removeActivityResultListener(pigeon_instanceArg, listenerArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothLowEnergyAndroidPlugin and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: dev.hebei.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLowEnergyAndroidPlugin.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
@Suppress("UNCHECKED_CAST")
open class PigeonApiRequestPermissionsResultListener(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of RequestPermissionsResultListener and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: io.flutter.plugin.common.PluginRegistry.RequestPermissionsResultListener, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of RequestPermissionsResultListener, but the class has a nonnull callback method.", "")))
    }
  }

  fun onRequestPermissionsResult(pigeon_instanceArg: io.flutter.plugin.common.PluginRegistry.RequestPermissionsResultListener, requestCodeArg: Long, permissionsArg: List<String>, grantResultsArg: List<Long>, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.RequestPermissionsResultListener.onRequestPermissionsResult"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, requestCodeArg, permissionsArg, grantResultsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

}
@Suppress("UNCHECKED_CAST")
open class PigeonApiActivityResultListener(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ActivityResultListener and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: io.flutter.plugin.common.PluginRegistry.ActivityResultListener, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of ActivityResultListener, but the class has a nonnull callback method.", "")))
    }
  }

  fun onActivityResult(pigeon_instanceArg: io.flutter.plugin.common.PluginRegistry.ActivityResultListener, requestCodeArg: Long, resultCodeArg: Long, dataArg: android.content.Intent?, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ActivityResultListener.onActivityResult"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, requestCodeArg, resultCodeArg, dataArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

}
/**
 * The root of the Kotlin class hierarchy. Every Kotlin class has Any as a
 * superclass.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAny(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): Any

  /**
   * Indicates whether some other object is "equal to" this one. Implementations
   * must fulfil the following requirements:
   */
  abstract fun equals(pigeon_instance: Any, other: Any?): Boolean

  /**
   * Returns a hash code value for the object.  The general contract of hashCode
   * is:
   */
  abstract fun hashCodeX(pigeon_instance: Any): Long

  /** Returns a string representation of the object. */
  abstract fun toStringX(pigeon_instance: Any): String

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAny?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.Any.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.Any.equals", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as Any
            val otherArg = args[1]
            val wrapped: List<Any?> = try {
              listOf(api.equals(pigeon_instanceArg, otherArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.Any.hashCodeX", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as Any
            val wrapped: List<Any?> = try {
              listOf(api.hashCodeX(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.Any.toStringX", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as Any
            val wrapped: List<Any?> = try {
              listOf(api.toStringX(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of Any and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: Any, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.Any.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

}
@Suppress("UNCHECKED_CAST")
open class PigeonApiActivity(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of Activity and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.app.Activity, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.Activity.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiContext] used to access callback methods */
  fun pigeon_getPigeonApiContext(): PigeonApiContext
  {
    return pigeonRegistrar.getPigeonApiContext()
  }

}
/**
 * A description of an Intent and target action to perform with it. Instances of
 * this class are created with #getActivity, #getActivities, getBroadcast, and
 * getService; the returned object can be handed to other applications so that
 * they can perform the action you described on your behalf at a later time.
 *
 * By giving a PendingIntent to another application, you are granting it the
 * right to perform the operation you have specified as if the other application
 * was yourself (with the same permissions and identity). As such, you should be
 * careful about how you build the PendingIntent: almost always, for example,
 * the base Intent you supply should have the component name explicitly set to
 * one of your own components, to ensure it is ultimately sent there and nowhere
 * else.
 *
 * A PendingIntent itself is simply a reference to a token maintained by the
 * system describing the original data used to retrieve it. This means that, even
 * if its owning application's process is killed, the PendingIntent itself will
 * remain usable from other processes that have been given it. If the creating
 * application later re-retrieves the same kind of PendingIntent (same operation,
 * same Intent action, data, categories, and components, and same flags), it will
 * receive a PendingIntent representing the same token if that is still valid,
 * and can thus call cancel to remove it.
 *
 * Because of this behavior, it is important to know when two Intents are considered
 * to be the same for purposes of retrieving a PendingIntent. A common mistake
 * people make is to create multiple PendingIntent objects with Intents that only
 * vary in their "extra" contents, expecting to get a different PendingIntent
 * each time. This does not happen. The parts of the Intent that are used for
 * matching are the same ones defined by Intent.filterEquals. If you use two
 * Intent objects that are equivalent as per Intent.filterEquals, then you will
 * get the same PendingIntent for both of them.
 *
 * There are two typical ways to deal with this.
 *
 * If you truly need multiple distinct PendingIntent objects active at the same
 * time (such as to use as two notifications that are both shown at the same
 * time), then you will need to ensure there is something that is different about
 * them to associate them with different PendingIntents. This may be any of the
 * Intent attributes considered by Intent.filterEquals, or different request code
 * integers supplied to #getActivity, #getActivities, getBroadcast, or getService.
 *
 * If you only need one PendingIntent active at a time for any of the Intents
 * you will use, then you can alternatively use the flags FLAG_CANCEL_CURRENT or
 * FLAG_UPDATE_CURRENT to either cancel or modify whatever current PendingIntent
 * is associated with the Intent you are supplying.
 *
 * Also note that flags like FLAG_ONE_SHOT or FLAG_IMMUTABLE describe the
 * PendingIntent instance and thus, are used to identify it. Any calls to retrieve
 * or modify a PendingIntent created with these flags will also require these
 * flags to be supplied in conjunction with others. E.g. To retrieve an existing
 * PendingIntent created with FLAG_ONE_SHOT, both FLAG_ONE_SHOT and FLAG_NO_CREATE
 * need to be supplied.
 */
@Suppress("UNCHECKED_CAST")
open class PigeonApiPendingIntent(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of PendingIntent and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.app.PendingIntent, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.PendingIntent.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Represents the local device Bluetooth adapter. The BluetoothAdapter lets you
 * perform fundamental Bluetooth tasks, such as initiate device discovery, query
 * a list of bonded (paired) devices, instantiate a BluetoothDevice using a known
 * MAC address, and create a BluetoothServerSocket to listen for connection
 * requests from other devices, and start a scan for Bluetooth LE devices.
 *
 * To get a BluetoothAdapter representing the local Bluetooth adapter, call the
 * android.bluetooth.BluetoothManager#getAdapter function on BluetoothManager.
 * On JELLY_BEAN_MR1 and below you will need to use the static getDefaultAdapter
 * method instead.
 *
 * Fundamentally, this is your starting point for all Bluetooth actions. Once
 * you have the local adapter, you can get a set of BluetoothDevice objects
 * representing all paired devices with getBondedDevices(); start device discovery
 * with startDiscovery(); or create a BluetoothServerSocket to listen for incoming
 * RFComm connection requests with listenUsingRfcommWithServiceRecord(java.lang.String,java.util.UUID);
 * listen for incoming L2CAP Connection-oriented Channels (CoC) connection requests
 * with listenUsingL2capChannel(); or start a scan for Bluetooth LE devices with
 * BluetoothLeScanner.startScan(ScanCallback) using the scanner from
 * getBluetoothLeScanner().
 *
 * This class is thread safe.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothAdapter(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Cancel the current device discovery process.
   *
   * Because discovery is a heavyweight procedure for the Bluetooth adapter, this
   * method should always be called before attempting to connect to a remote
   * device with android.bluetooth.BluetoothSocket#connect(). Discovery is not
   * managed by the Activity, but is run as a system service, so an application
   * should always call cancel discovery even if it did not directly request a
   * discovery, just to be sure.
   *
   * If Bluetooth state is not STATE_ON, this API will return false. After turning
   * on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated
   * value.
   */
  abstract fun cancelDiscovery(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /**
   * Validate a String Bluetooth address, such as "00:43:A8:23:10:F0"
   *
   * Alphabetic characters must be uppercase to be valid.
   */
  abstract fun checkBluetoothAddress(address: String): Boolean

  /**
   * Close the connection of the profile proxy to the Service.
   *
   * Clients should call this when they are no longer using the proxy obtained
   * from getProfileProxy. Profile can be one of BluetoothProfile.HEADSET or
   * android.bluetooth.BluetoothProfile#A2DP
   */
  abstract fun closeProfileProxy(pigeon_instance: android.bluetooth.BluetoothAdapter, unusedProfile: Long, proxy: android.bluetooth.BluetoothProfile)

  /**
   * Turn off the local Bluetooth adapterdo not use without explicit user action
   * to turn off Bluetooth.
   *
   * This gracefully shuts down all Bluetooth connections, stops Bluetooth system
   * services, and powers down the underlying Bluetooth hardware.
   *
   * Bluetooth should never be disabled without direct user consent. The disable()
   * method is provided only for applications that include a user interface for
   * changing system settings, such as a "power manager" app.
   *
   * This is an asynchronous call: it will return immediately, and clients should
   * listen for ACTION_STATE_CHANGED to be notified of subsequent adapter state
   * changes. If this call returns true, then the adapter state will immediately
   * transition from STATE_ON to STATE_TURNING_OFF, and some time later transition
   * to either STATE_OFF or STATE_ON. If this call returns false then there was
   * an immediate problem that will prevent the adapter from being turned off -
   * such as the adapter already being turned off.
   */
  abstract fun disable(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /**
   * Turn on the local Bluetooth adapterdo not use without explicit user action
   * to turn on Bluetooth.
   *
   * This powers on the underlying Bluetooth hardware, and starts all Bluetooth
   * system services.
   *
   * Bluetooth should never be enabled without direct user consent. If you want
   * to turn on Bluetooth in order to create a wireless connection, you should
   * use the ACTION_REQUEST_ENABLE Intent, which will raise a dialog that requests
   * user permission to turn on Bluetooth. The enable() method is provided only
   * for applications that include a user interface for changing system settings,
   * such as a "power manager" app.
   *
   * This is an asynchronous call: it will return immediately, and clients should
   * listen for ACTION_STATE_CHANGED to be notified of subsequent adapter state
   * changes. If this call returns true, then the adapter state will immediately
   * transition from STATE_OFF to STATE_TURNING_ON, and some time later transition
   * to either STATE_OFF or STATE_ON. If this call returns false then there was
   * an immediate problem that will prevent the adapter from being turned on -
   * such as Airplane mode, or the adapter is already turned on.
   */
  abstract fun enable(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /**
   * Returns the hardware address of the local Bluetooth adapter.
   *
   * For example, "00:11:22:AA:BB:CC".
   */
  abstract fun getAddress(pigeon_instance: android.bluetooth.BluetoothAdapter): String

  /**
   * Returns a BluetoothLeAdvertiser object for Bluetooth LE Advertising operations.
   * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising
   * is not supported on this device.
   *
   * Use isMultipleAdvertisementSupported() to check whether LE Advertising is
   * supported on this device before calling this method.
   */
  abstract fun getBluetoothLeAdvertiser(pigeon_instance: android.bluetooth.BluetoothAdapter): android.bluetooth.le.BluetoothLeAdvertiser

  /** Returns a BluetoothLeScanner object for Bluetooth LE scan operations. */
  abstract fun getBluetoothLeScanner(pigeon_instance: android.bluetooth.BluetoothAdapter): android.bluetooth.le.BluetoothLeScanner

  /**
   * Return the set of BluetoothDevice objects that are bonded (paired) to the
   * local adapter.
   *
   * If Bluetooth state is not STATE_ON, this API will return an empty set. After
   * turning on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get
   * the updated value.
   */
  abstract fun getBondedDevices(pigeon_instance: android.bluetooth.BluetoothAdapter): List<android.bluetooth.BluetoothDevice>

  /**
   * Get a handle to the default local Bluetooth adapter.
   *
   * Currently Android only supports one Bluetooth adapter, but the API could be
   * extended to support more. This will always return the default adapter.
   */
  abstract fun getDefaultAdapter(): android.bluetooth.BluetoothAdapter

  /** Get the timeout duration of the SCAN_MODE_CONNECTABLE_DISCOVERABLE. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun getDiscoverableTimeout(pigeon_instance: android.bluetooth.BluetoothAdapter): java.time.Duration?

  /**
   * Return the maximum LE advertising data length in bytes, if LE Extended
   * Advertising feature is supported, 0 otherwise.
   */
  abstract fun getLeMaximumAdvertisingDataLength(pigeon_instance: android.bluetooth.BluetoothAdapter): Long

  /**
   * Get the maximum number of connected devices per audio profile for this
   * device.
   */
  abstract fun getMaxConnectedAudioDevices(pigeon_instance: android.bluetooth.BluetoothAdapter): Long

  /**
   * Get the friendly Bluetooth name of the local Bluetooth adapter.
   *
   * This name is visible to remote Bluetooth devices.
   */
  abstract fun getName(pigeon_instance: android.bluetooth.BluetoothAdapter): String

  /**
   * Get the current connection state of a profile. This function can be used to
   * check whether the local Bluetooth adapter is connected to any remote device
   * for a specific profile. Profile can be one of BluetoothProfile.HEADSET,
   * BluetoothProfile.A2DP.
   *
   * Return the profile connection state
   */
  abstract fun getProfileConnectionState(pigeon_instance: android.bluetooth.BluetoothAdapter, profile: Long): Long

  /**
   * Get the profile proxy object associated with the profile.
   *
   * The ServiceListener's methods will be invoked on the application's main
   * looper
   */
  abstract fun getProfileProxy(pigeon_instance: android.bluetooth.BluetoothAdapter, context: android.content.Context, listener: android.bluetooth.BluetoothProfile.ServiceListener, profile: Long): Boolean

  /**
   * Get a BluetoothDevice object for the given Bluetooth hardware address.
   *
   * Valid Bluetooth hardware addresses must be 6 bytes. This method expects the
   * address in network byte order (MSB first).
   *
   * A BluetoothDevice will always be returned for a valid hardware address, even
   * if this adapter has never seen that device.
   */
  abstract fun getRemoteDevice1(pigeon_instance: android.bluetooth.BluetoothAdapter, address: ByteArray): android.bluetooth.BluetoothDevice

  /**
   * Get a BluetoothDevice object for the given Bluetooth hardware address.
   *
   * Valid Bluetooth hardware addresses must be upper case, in big endian byte
   * order, and in a format such as "00:11:22:33:AA:BB". The helper checkBluetoothAddress
   * is available to validate a Bluetooth address.
   *
   * A BluetoothDevice will always be returned for a valid hardware address, even
   * if this adapter has never seen that device.
   */
  abstract fun getRemoteDevice2(pigeon_instance: android.bluetooth.BluetoothAdapter, address: String): android.bluetooth.BluetoothDevice

  /**
   * Get a BluetoothDevice object for the given Bluetooth hardware address and
   * addressType.
   *
   * Valid Bluetooth hardware addresses must be upper case, in big endian byte
   * order, and in a format such as "00:11:22:33:AA:BB". The helper checkBluetoothAddress
   * is available to validate a Bluetooth address.
   *
   * A BluetoothDevice will always be returned for a valid hardware address and
   * type, even if this adapter has never seen that device.
   */
  abstract fun getRemoteLeDevice(pigeon_instance: android.bluetooth.BluetoothAdapter, address: String, addressType: Long): android.bluetooth.BluetoothDevice

  /**
   * Get the current Bluetooth scan mode of the local Bluetooth adapter.
   *
   * The Bluetooth scan mode determines if the local adapter is connectable
   * and/or discoverable from remote Bluetooth devices.
   *
   * Possible values are: SCAN_MODE_NONE, SCAN_MODE_CONNECTABLE,
   * SCAN_MODE_CONNECTABLE_DISCOVERABLE.
   *
   * If Bluetooth state is not STATE_ON, this API will return SCAN_MODE_NONE.
   * After turning on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to
   * get the updated value.
   */
  abstract fun getScanMode(pigeon_instance: android.bluetooth.BluetoothAdapter): Long

  /**
   * Get the current state of the local Bluetooth adapter.
   *
   * Possible return values are STATE_OFF, STATE_TURNING_ON, STATE_ON,
   * STATE_TURNING_OFF.
   */
  abstract fun getState(pigeon_instance: android.bluetooth.BluetoothAdapter): Long

  /**
   * Return true if the local Bluetooth adapter is currently in the device
   * discovery process.
   *
   * Device discovery is a heavyweight procedure. New connections to remote
   * Bluetooth devices should not be attempted while discovery is in progress,
   * and existing connections will experience limited bandwidth and high latency.
   * Use cancelDiscovery() to cancel an ongoing discovery.
   *
   * Applications can also register for ACTION_DISCOVERY_STARTED or
   * ACTION_DISCOVERY_FINISHED to be notified when discovery starts or completes.
   *
   * If Bluetooth state is not STATE_ON, this API will return false. After turning
   * on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated
   * value.
   */
  abstract fun isDiscovering(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /**
   * Return true if Bluetooth is currently enabled and ready for use.
   *
   * Equivalent to: getBluetoothState() == STATE_ON
   */
  abstract fun isEnabled(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /** Return true if LE 2M PHY feature is supported. */
  abstract fun isLe2MPhySupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /**
   * Returns BluetoothStatusCodes.FEATURE_SUPPORTED if the LE audio broadcast
   * assistant feature is supported, BluetoothStatusCodes.FEATURE_NOT_SUPPORTED
   * if the feature is not supported, or an error code.
   */
  abstract fun isLeAudioBroadcastAssistantSupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Long

  /**
   * Returns BluetoothStatusCodes.FEATURE_SUPPORTED if the LE audio broadcast
   * source feature is supported, BluetoothStatusCodes.FEATURE_NOT_SUPPORTED if
   * the feature is not supported, or an error code.
   */
  abstract fun isLeAudioBroadcastSourceSupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Long

  /**
   * Returns BluetoothStatusCodes.FEATURE_SUPPORTED if the LE audio feature is
   * supported, BluetoothStatusCodes.FEATURE_NOT_SUPPORTED if the feature is not
   * supported, or an error code.
   */
  abstract fun isLeAudioSupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Long

  /** Return true if LE Coded PHY feature is supported. */
  abstract fun isLeCodedPhySupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /** Return true if LE Extended Advertising feature is supported. */
  abstract fun isLeExtendedAdvertisingSupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /** Return true if LE Periodic Advertising feature is supported. */
  abstract fun isLePeriodicAdvertisingSupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /** Return true if the multi advertisement is supported by the chipset */
  abstract fun isMultipleAdvertisementSupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /** Return true if offloaded filters are supported */
  abstract fun isOffloadedFilteringSupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /** Return true if offloaded scan batching is supported */
  abstract fun isOffloadedScanBatchingSupported(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /**
   * Create an insecure L2CAP Connection-oriented Channel (CoC) BluetoothServerSocket
   * and assign a dynamic PSM value. This socket can be used to listen for
   * incoming connections. The supported Bluetooth transport is LE only.
   *
   * The link key is not required to be authenticated, i.e. the communication
   * may be vulnerable to person-in-the-middle attacks. Use listenUsingL2capChannel,
   * if an encrypted and authenticated communication channel is desired.
   *
   * Use android.bluetooth.BluetoothServerSocket#accept to retrieve incoming
   * connections from a listening BluetoothServerSocket.
   *
   * The system will assign a dynamic protocol/service multiplexer (PSM) value.
   * This PSM value can be read from the BluetoothServerSocket.getPsm() and this
   * value will be released when this server socket is closed, Bluetooth is turned
   * off, or the application exits unexpectedly.
   *
   * The mechanism of disclosing the assigned dynamic PSM value to the initiating
   * peer is defined and performed by the application.
   *
   * Use BluetoothDevice.createInsecureL2capChannel(int) to connect to this server
   * socket from another Android device that is given the PSM value.
   */
  abstract fun listenUsingInsecureL2capChannel(pigeon_instance: android.bluetooth.BluetoothAdapter): android.bluetooth.BluetoothServerSocket

  /**
   * Create a listening, insecure RFCOMM Bluetooth socket with Service Record.
   *
   * The link key is not required to be authenticated, i.e. the communication may be vulnerable to Person In the Middle attacks. For Bluetooth 2.1 devices, the link will be encrypted, as encryption is mandatory. For legacy devices (pre Bluetooth 2.1 devices) the link will not be encrypted. Use listenUsingRfcommWithServiceRecord, if an encrypted and authenticated communication channel is desired.
   *
   * Use android.bluetooth.BluetoothServerSocket#accept to retrieve incoming connections from a listening BluetoothServerSocket.
   *
   * The system will assign an unused RFCOMM channel to listen on.
   *
   * The system will also register a Service Discovery Protocol (SDP) record with the local SDP server containing the specified UUID, service name, and auto-assigned channel. Remote Bluetooth devices can use the same UUID to query our SDP server and discover which channel to connect to. This SDP record will be removed when this socket is closed, or if this application closes unexpectedly.
   *
   * Use BluetoothDevice.createInsecureRfcommSocketToServiceRecord to connect to this socket from another device using the same UUID.
   */
  abstract fun listenUsingInsecureRfcommWithServiceRecord(pigeon_instance: android.bluetooth.BluetoothAdapter, name: String, uuid: java.util.UUID): android.bluetooth.BluetoothServerSocket

  /**
   * Create a secure L2CAP Connection-oriented Channel (CoC) BluetoothServerSocket
   * and assign a dynamic protocol/service multiplexer (PSM) value. This socket
   * can be used to listen for incoming connections. The supported Bluetooth
   * transport is LE only.
   *
   * A remote device connecting to this socket will be authenticated and
   * communication on this socket will be encrypted.
   *
   * Use BluetoothServerSocket.accept to retrieve incoming connections from a
   * listening BluetoothServerSocket.
   *
   * The system will assign a dynamic PSM value. This PSM value can be read from
   * the BluetoothServerSocket.getPsm() and this value will be released when this
   * server socket is closed, Bluetooth is turned off, or the application exits
   * unexpectedly.
   *
   * The mechanism of disclosing the assigned dynamic PSM value to the initiating
   * peer is defined and performed by the application.
   *
   * Use BluetoothDevice.createL2capChannel(int) to connect to this server socket
   * from another Android device that is given the PSM value.
   */
  abstract fun listenUsingL2capChannel(pigeon_instance: android.bluetooth.BluetoothAdapter): android.bluetooth.BluetoothServerSocket

  /**
   * Create a listening, secure RFCOMM Bluetooth socket with Service Record.
   *
   * A remote device connecting to this socket will be authenticated and
   * communication on this socket will be encrypted.
   *
   * Use BluetoothServerSocket.accept to retrieve incoming connections from a
   * listening BluetoothServerSocket.
   *
   * The system will assign an unused RFCOMM channel to listen on.
   *
   * The system will also register a Service Discovery Protocol (SDP) record with
   * the local SDP server containing the specified UUID, service name, and
   * auto-assigned channel. Remote Bluetooth devices can use the same UUID to
   * query our SDP server and discover which channel to connect to. This SDP
   * record will be removed when this socket is closed, or if this application
   * closes unexpectedly.
   *
   * Use BluetoothDevice.createRfcommSocketToServiceRecord to connect to this
   * socket from another device using the same UUID.
   */
  abstract fun listenUsingRfcommWithServiceRecord(pigeon_instance: android.bluetooth.BluetoothAdapter, name: String, uuid: java.util.UUID): android.bluetooth.BluetoothServerSocket

  /**
   * Set the friendly Bluetooth name of the local Bluetooth adapter.
   *
   * This name is visible to remote Bluetooth devices.
   *
   * Valid Bluetooth names are a maximum of 248 bytes using UTF-8 encoding,
   * although many remote devices can only display the first 40 characters, and
   * some may be limited to just 20.
   *
   * If Bluetooth state is not STATE_ON, this API will return false. After turning
   * on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated
   * value.
   */
  abstract fun setName(pigeon_instance: android.bluetooth.BluetoothAdapter, name: String): Boolean

  /**
   * Start the remote device discovery process.
   *
   * The discovery process usually involves an inquiry scan of about 12 seconds,
   * followed by a page scan of each new device to retrieve its Bluetooth name.
   *
   * This is an asynchronous call, it will return immediately. Register for
   * ACTION_DISCOVERY_STARTED and ACTION_DISCOVERY_FINISHED intents to determine
   * exactly when the discovery starts and completes. Register for
   * BluetoothDevice.ACTION_FOUND to be notified as remote Bluetooth devices are
   * found.
   *
   * Device discovery is a heavyweight procedure. New connections to remote
   * Bluetooth devices should not be attempted while discovery is in progress,
   * and existing connections will experience limited bandwidth and high latency.
   * Use cancelDiscovery() to cancel an ongoing discovery. Discovery is not
   * managed by the Activity, but is run as a system service, so an application
   * should always call BluetoothAdapter.cancelDiscovery() even if it did not
   * directly request a discovery, just to be sure.
   *
   * Device discovery will only find remote devices that are currently discoverable
   * (inquiry scan enabled). Many Bluetooth devices are not discoverable by
   * default, and need to be entered into a special mode.
   *
   * If Bluetooth state is not STATE_ON, this API will return false. After turning
   * on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated
   * value.
   *
   * If a device is currently bonding, this request will be queued and executed
   * once that device has finished bonding. If a request is already queued, this
   * request will be ignored.
   */
  abstract fun startDiscovery(pigeon_instance: android.bluetooth.BluetoothAdapter): Boolean

  /**
   * Starts a scan for Bluetooth LE devices.
   *
   * Results of the scan are reported using the LeScanCallback.onLeScan callback.
   */
  abstract fun startLeScan1(pigeon_instance: android.bluetooth.BluetoothAdapter, callback: android.bluetooth.BluetoothAdapter.LeScanCallback): Boolean

  /**
   * Starts a scan for Bluetooth LE devices, looking for devices that advertise
   * given services.
   *
   * Devices which advertise all specified services are reported using the
   * BluetoothAdapter.LeScanCallback.onLeScan(BluetoothDevice, int, byte) callback.
   */
  abstract fun startLeScan2(pigeon_instance: android.bluetooth.BluetoothAdapter, serviceUuids: List<java.util.UUID>, callback: android.bluetooth.BluetoothAdapter.LeScanCallback): Boolean

  /** Stops an ongoing Bluetooth LE device scan. */
  abstract fun stopLeScan(pigeon_instance: android.bluetooth.BluetoothAdapter, callback: android.bluetooth.BluetoothAdapter.LeScanCallback)

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothAdapter?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.cancelDiscovery", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.cancelDiscovery(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.checkBluetoothAddress", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val addressArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.checkBluetoothAddress(addressArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.closeProfileProxy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val unusedProfileArg = args[1] as Long
            val proxyArg = args[2] as android.bluetooth.BluetoothProfile
            val wrapped: List<Any?> = try {
              api.closeProfileProxy(pigeon_instanceArg, unusedProfileArg, proxyArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.disable", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.disable(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.enable", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.enable(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getAddress", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getAddress(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getBluetoothLeAdvertiser", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getBluetoothLeAdvertiser(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getBluetoothLeScanner", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getBluetoothLeScanner(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getBondedDevices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getBondedDevices(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getDefaultAdapter", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getDefaultAdapter())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getDiscoverableTimeout", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
              val wrapped: List<Any?> = try {
                listOf(api.getDiscoverableTimeout(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getDiscoverableTimeout",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `java.time.Duration`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getLeMaximumAdvertisingDataLength", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getLeMaximumAdvertisingDataLength(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getMaxConnectedAudioDevices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getMaxConnectedAudioDevices(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getName(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getProfileConnectionState", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val profileArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getProfileConnectionState(pigeon_instanceArg, profileArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getProfileProxy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val contextArg = args[1] as android.content.Context
            val listenerArg = args[2] as android.bluetooth.BluetoothProfile.ServiceListener
            val profileArg = args[3] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getProfileProxy(pigeon_instanceArg, contextArg, listenerArg, profileArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getRemoteDevice1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val addressArg = args[1] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.getRemoteDevice1(pigeon_instanceArg, addressArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getRemoteDevice2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val addressArg = args[1] as String
            val wrapped: List<Any?> = try {
              listOf(api.getRemoteDevice2(pigeon_instanceArg, addressArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getRemoteLeDevice", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val addressArg = args[1] as String
            val addressTypeArg = args[2] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getRemoteLeDevice(pigeon_instanceArg, addressArg, addressTypeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getScanMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getScanMode(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.getState", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.getState(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isDiscovering", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isDiscovering(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isEnabled", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isEnabled(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isLe2MPhySupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isLe2MPhySupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isLeAudioBroadcastAssistantSupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isLeAudioBroadcastAssistantSupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isLeAudioBroadcastSourceSupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isLeAudioBroadcastSourceSupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isLeAudioSupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isLeAudioSupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isLeCodedPhySupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isLeCodedPhySupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isLeExtendedAdvertisingSupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isLeExtendedAdvertisingSupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isLePeriodicAdvertisingSupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isLePeriodicAdvertisingSupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isMultipleAdvertisementSupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isMultipleAdvertisementSupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isOffloadedFilteringSupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isOffloadedFilteringSupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.isOffloadedScanBatchingSupported", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.isOffloadedScanBatchingSupported(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.listenUsingInsecureL2capChannel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.listenUsingInsecureL2capChannel(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.listenUsingInsecureRfcommWithServiceRecord", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val nameArg = args[1] as String
            val uuidArg = args[2] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.listenUsingInsecureRfcommWithServiceRecord(pigeon_instanceArg, nameArg, uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.listenUsingL2capChannel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.listenUsingL2capChannel(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.listenUsingRfcommWithServiceRecord", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val nameArg = args[1] as String
            val uuidArg = args[2] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.listenUsingRfcommWithServiceRecord(pigeon_instanceArg, nameArg, uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.setName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val nameArg = args[1] as String
            val wrapped: List<Any?> = try {
              listOf(api.setName(pigeon_instanceArg, nameArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.startDiscovery", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val wrapped: List<Any?> = try {
              listOf(api.startDiscovery(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.startLeScan1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val callbackArg = args[1] as android.bluetooth.BluetoothAdapter.LeScanCallback
            val wrapped: List<Any?> = try {
              listOf(api.startLeScan1(pigeon_instanceArg, callbackArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.startLeScan2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val serviceUuidsArg = args[1] as List<java.util.UUID>
            val callbackArg = args[2] as android.bluetooth.BluetoothAdapter.LeScanCallback
            val wrapped: List<Any?> = try {
              listOf(api.startLeScan2(pigeon_instanceArg, serviceUuidsArg, callbackArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.stopLeScan", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothAdapter
            val callbackArg = args[1] as android.bluetooth.BluetoothAdapter.LeScanCallback
            val wrapped: List<Any?> = try {
              api.stopLeScan(pigeon_instanceArg, callbackArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothAdapter and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothAdapter, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothAdapter.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Represents a Bluetooth class, which describes general characteristics and
 * capabilities of a device. For example, a Bluetooth class will specify the
 * general device type such as a phone, a computer, or headset, and whether it's
 * capable of services such as audio or telephony.
 *
 * Every Bluetooth class is composed of zero or more service classes, and exactly
 * one device class. The device class is further broken down into major and minor
 * device class components.
 *
 * BluetoothClass is useful as a hint to roughly describe a device (for example
 * to show an icon in the UI), but does not reliably describe which Bluetooth
 * profiles or services are actually supported by a device. Accurate service
 * discovery is done through SDP requests, which are automatically performed when
 * creating an RFCOMM socket with android.bluetooth.BluetoothDevice#createRfcommSocketToServiceRecord
 * and android.bluetooth.BluetoothAdapter#listenUsingRfcommWithServiceRecord
 *
 * Use BluetoothDevice.getBluetoothClass to retrieve the class for a remote device.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothClass(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Check class bits for possible bluetooth profile support. This is a simple
   * heuristic that tries to guess if a device with the given class bits might
   * support specified profile. It is not accurate for all devices. It tries to
   * err on the side of false positives.
   */
  abstract fun doesClassMatch(pigeon_instance: android.bluetooth.BluetoothClass, profile: Long): Boolean

  /**
   * Return the (major and minor) device class component of this BluetoothClass.
   *
   * Values returned from this function can be compared with the public constants
   * in BluetoothClass.Device to determine which device class is encoded in this
   * Bluetooth class.
   */
  abstract fun getDeviceClass(pigeon_instance: android.bluetooth.BluetoothClass): Long

  /**
   * Return the major device class component of this BluetoothClass.
   *
   * Values returned from this function can be compared with the public constants
   * in BluetoothClass.Device.Major to determine which major class is encoded in
   * this Bluetooth class.
   */
  abstract fun getMajorDeviceClass(pigeon_instance: android.bluetooth.BluetoothClass): Long

  /**
   * Return true if the specified service class is supported by this BluetoothClass.
   *
   * Valid service classes are the public constants in BluetoothClass.Service.
   * For example, BluetoothClass.Service.AUDIO.
   */
  abstract fun hasService(pigeon_instance: android.bluetooth.BluetoothClass, service: Long): Boolean

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothClass?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothClass.doesClassMatch", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothClass
            val profileArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.doesClassMatch(pigeon_instanceArg, profileArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothClass.getDeviceClass", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothClass
            val wrapped: List<Any?> = try {
              listOf(api.getDeviceClass(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothClass.getMajorDeviceClass", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothClass
            val wrapped: List<Any?> = try {
              listOf(api.getMajorDeviceClass(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothClass.hasService", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothClass
            val serviceArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.hasService(pigeon_instanceArg, serviceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothClass and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothClass, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothClass.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Represents a remote Bluetooth device. A BluetoothDevice lets you create a
 * connection with the respective device or query information about it, such as
 * the name, address, class, and bonding state.
 *
 * This class is really just a thin wrapper for a Bluetooth hardware address.
 * Objects of this class are immutable. Operations on this class are performed
 * on the remote Bluetooth hardware address, using the BluetoothAdapter that was
 * used to create this BluetoothDevice.
 *
 * To get a BluetoothDevice, use BluetoothAdapter.getRemoteDevice(String) to
 * create one representing a device of a known MAC address (which you can get
 * through device discovery with BluetoothAdapter) or get one from the set of
 * bonded devices returned by BluetoothAdapter.getBondedDevices(). You can then
 * open a BluetoothSocket for communication with the remote device, using
 * createRfcommSocketToServiceRecord(java.util.UUID) over Bluetooth BR/EDR or
 * using createL2capChannel(int) over Bluetooth LE.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothDevice(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Connect to GATT Server hosted by this device. Caller acts as GATT client.
   * The callback is used to deliver results to Caller, such as connection status
   * as well as any further GATT client operations. The method returns a
   * BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client
   * operations.
   */
  abstract fun connectGatt1(pigeon_instance: android.bluetooth.BluetoothDevice, context: android.content.Context, autoConnect: Boolean, callback: android.bluetooth.BluetoothGattCallback): android.bluetooth.BluetoothGatt

  /**
   * Connect to GATT Server hosted by this device. Caller acts as GATT client.
   * The callback is used to deliver results to Caller, such as connection status
   * as well as any further GATT client operations. The method returns a
   * BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client
   * operations.
   */
  abstract fun connectGatt2(pigeon_instance: android.bluetooth.BluetoothDevice, context: android.content.Context, autoConnect: Boolean, callback: android.bluetooth.BluetoothGattCallback, transport: Long): android.bluetooth.BluetoothGatt

  /**
   * Connect to GATT Server hosted by this device. Caller acts as GATT client.
   * The callback is used to deliver results to Caller, such as connection status
   * as well as any further GATT client operations. The method returns a
   * BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client
   * operations.
   */
  abstract fun connectGatt3(pigeon_instance: android.bluetooth.BluetoothDevice, context: android.content.Context, autoConnect: Boolean, callback: android.bluetooth.BluetoothGattCallback, transport: Long, phy: Long): android.bluetooth.BluetoothGatt

  /**
   * Connect to GATT Server hosted by this device. Caller acts as GATT client.
   * The callback is used to deliver results to Caller, such as connection status
   * as well as any further GATT client operations. The method returns a
   * BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client
   * operations.
   */
  abstract fun connectGatt4(pigeon_instance: android.bluetooth.BluetoothDevice, context: android.content.Context, autoConnect: Boolean, callback: android.bluetooth.BluetoothGattCallback, transport: Long, phy: Long, handler: android.os.Handler): android.bluetooth.BluetoothGatt

  /**
   * Start the bonding (pairing) process with the remote device.
   *
   * This is an asynchronous call, it will return immediately. Register for
   * ACTION_BOND_STATE_CHANGED intents to be notified when the bonding process
   * completes, and its result.
   *
   * Android system services will handle the necessary user interactions to
   * confirm and complete the bonding process.
   */
  abstract fun createBond(pigeon_instance: android.bluetooth.BluetoothDevice): Boolean

  /**
   * Create a Bluetooth L2CAP Connection-oriented Channel (CoC) BluetoothSocket
   * that can be used to start a secure outgoing connection to the remote device
   * with the same dynamic protocol/service multiplexer (PSM) value. The supported
   * Bluetooth transport is LE only.
   *
   * This is designed to be used with android.bluetooth.BluetoothAdapter#listenUsingInsecureL2capChannel()
   * for peer-peer Bluetooth applications.
   *
   * Use BluetoothSocket.connect to initiate the outgoing connection.
   *
   * Application using this API is responsible for obtaining PSM value from remote
   * device.
   *
   * The communication channel may not have an authenticated link key, i.e. it
   * may be subject to person-in-the-middle attacks. Use createL2capChannel(int)
   * if an encrypted and authenticated communication channel is possible.
   */
  abstract fun createInsecureL2capChannel(pigeon_instance: android.bluetooth.BluetoothDevice, psm: Long): android.bluetooth.BluetoothSocket

  /**
   * Create an RFCOMM BluetoothSocket socket ready to start an insecure outgoing
   * connection to this remote device using SDP lookup of uuid.
   *
   * The communication channel will not have an authenticated link key i.e. it
   * will be subject to person-in-the-middle attacks. For Bluetooth 2.1 devices,
   * the link key will be encrypted, as encryption is mandatory. For legacy
   * devices (pre Bluetooth 2.1 devices) the link key will be not be encrypted.
   * Use createRfcommSocketToServiceRecord if an encrypted and authenticated
   * communication channel is desired.
   *
   * This is designed to be used with android.bluetooth.BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord
   * for peer-peer Bluetooth applications.
   *
   * Use BluetoothSocket.connect to initiate the outgoing connection. This will
   * also perform an SDP lookup of the given uuid to determine which channel to
   * connect to.
   *
   * The remote device will be authenticated and communication on this socket
   * will be encrypted.
   *
   * Hint: If you are connecting to a Bluetooth serial board then try using the
   * well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB. However if you
   * are connecting to an Android peer then please generate your own unique UUID.
   */
  abstract fun createInsecureRfcommSocketToServiceRecord(pigeon_instance: android.bluetooth.BluetoothDevice, uuid: java.util.UUID): android.bluetooth.BluetoothSocket

  /**
   * Create a Bluetooth L2CAP Connection-oriented Channel (CoC) BluetoothSocket
   * that can be used to start a secure outgoing connection to the remote device
   * with the same dynamic protocol/service multiplexer (PSM) value. The supported
   * Bluetooth transport is LE only.
   *
   * This is designed to be used with BluetoothAdapter.listenUsingL2capChannel()
   * for peer-peer Bluetooth applications.
   *
   * Use BluetoothSocket.connect to initiate the outgoing connection.
   *
   * Application using this API is responsible for obtaining PSM value from remote
   * device.
   *
   * The remote device will be authenticated and communication on this socket
   * will be encrypted.
   *
   * Use this socket if an authenticated socket link is possible. Authentication
   * refers to the authentication of the link key to prevent person-in-the-middle
   * type of attacks.
   */
  abstract fun createL2capChannel(pigeon_instance: android.bluetooth.BluetoothDevice, psm: Long): android.bluetooth.BluetoothSocket

  /**
   * Create an RFCOMM BluetoothSocket ready to start a secure outgoing connection
   * to this remote device using SDP lookup of uuid.
   *
   * This is designed to be used with android.bluetooth.BluetoothAdapter#listenUsingRfcommWithServiceRecord
   * for peer-peer Bluetooth applications.
   *
   * Use BluetoothSocket.connect to initiate the outgoing connection. This will
   * also perform an SDP lookup of the given uuid to determine which channel to
   * connect to.
   *
   * The remote device will be authenticated and communication on this socket
   * will be encrypted.
   *
   * Use this socket only if an authenticated socket link is possible. Authentication
   * refers to the authentication of the link key to prevent person-in-the-middle
   * type of attacks. For example, for Bluetooth 2.1 devices, if any of the
   * devices does not have an input and output capability or just has the ability
   * to display a numeric key, a secure socket connection is not possible. In
   * such a case, use createInsecureRfcommSocketToServiceRecord. For more details,
   * refer to the Security Model section 5.2 (vol 3) of Bluetooth Core Specification
   * version 2.1 + EDR.
   *
   * Hint: If you are connecting to a Bluetooth serial board then try using the
   * well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB. However if you
   * are connecting to an Android peer then please generate your own unique UUID.
   */
  abstract fun createRfcommSocketToServiceRecord(pigeon_instance: android.bluetooth.BluetoothDevice, uuid: java.util.UUID): android.bluetooth.BluetoothSocket

  /**
   * Perform a service discovery on the remote device to get the UUIDs supported.
   *
   * This API is asynchronous and ACTION_UUID intent is sent, with the UUIDs
   * supported by the remote end. If there is an error in getting the SDP records
   * or if the process takes a long time, or the device is bonding and we have
   * its UUIDs cached, ACTION_UUID intent is sent with the UUIDs that is currently
   * present in the cache. Clients should use the getUuids to get UUIDs if service
   * discovery is not to be performed. If there is an ongoing bonding process,
   * service discovery or device inquiry, the request will be queued.
   */
  abstract fun fetchUuidsWithSdp(pigeon_instance: android.bluetooth.BluetoothDevice): Boolean

  /**
   * Returns the address type of this BluetoothDevice, one of ADDRESS_TYPE_PUBLIC,
   * ADDRESS_TYPE_RANDOM, ADDRESS_TYPE_ANONYMOUS, or ADDRESS_TYPE_UNKNOWN.
   */
  abstract fun getAddressType(pigeon_instance: android.bluetooth.BluetoothDevice): Long

  /** Get the locally modifiable name (alias) of the remote Bluetooth device. */
  abstract fun getAlias(pigeon_instance: android.bluetooth.BluetoothDevice): String?

  /** Get the Bluetooth class of the remote device. */
  abstract fun getBluetoothClass(pigeon_instance: android.bluetooth.BluetoothDevice): android.bluetooth.BluetoothClass

  /**
   * Get the bond state of the remote device.
   *
   * Possible values for the bond state are: BOND_NONE, BOND_BONDING, BOND_BONDED.
   */
  abstract fun getBondState(pigeon_instance: android.bluetooth.BluetoothDevice): Long

  /**
   * Get the friendly Bluetooth name of the remote device.
   *
   * The local adapter will automatically retrieve remote names when performing
   * a device scan, and will cache them. This method just returns the name for
   * this device from the cache.
   */
  abstract fun getName(pigeon_instance: android.bluetooth.BluetoothDevice): String

  /** Get the Bluetooth device type of the remote device. */
  abstract fun getType(pigeon_instance: android.bluetooth.BluetoothDevice): Long

  /**
   * Returns the supported features (UUIDs) of the remote device.
   *
   * This method does not start a service discovery procedure to retrieve the
   * UUIDs from the remote device. Instead, the local cached copy of the service
   * UUIDs are returned.
   *
   * Use fetchUuidsWithSdp if fresh UUIDs are desired.
   */
  abstract fun getUuids(pigeon_instance: android.bluetooth.BluetoothDevice): List<android.os.ParcelUuid>

  /**
   * Sets the locally modifiable name (alias) of the remote Bluetooth device.
   * This method overwrites the previously stored alias. The new alias is saved
   * in local storage so that the change is preserved over power cycles.
   *
   * This method requires the calling app to have the android.Manifest.permission#BLUETOOTH_CONNECT permission. Additionally, an app must either have the android.Manifest.permission#BLUETOOTH_PRIVILEGED or be associated with the Companion Device manager (see android.companion.CompanionDeviceManager#associate( * AssociationRequest, android.companion.CompanionDeviceManager.Callback, Handler))
   */
  abstract fun setAlias(pigeon_instance: android.bluetooth.BluetoothDevice, alias: String?): Long

  /**
   * Confirm passkey for PAIRING_VARIANT_PASSKEY_CONFIRMATION pairing.
   *
   * Requires android.Manifest.permission#BLUETOOTH_CONNECT and
   * android.Manifest.permission#BLUETOOTH_PRIVILEGED
   */
  abstract fun setPairingConfirmation(pigeon_instance: android.bluetooth.BluetoothDevice, confirm: Boolean): Boolean

  /** Set the pin during pairing when the pairing method is PAIRING_VARIANT_PIN */
  abstract fun setPin(pigeon_instance: android.bluetooth.BluetoothDevice, pin: ByteArray): Boolean

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothDevice?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.connectGatt1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val contextArg = args[1] as android.content.Context
            val autoConnectArg = args[2] as Boolean
            val callbackArg = args[3] as android.bluetooth.BluetoothGattCallback
            val wrapped: List<Any?> = try {
              listOf(api.connectGatt1(pigeon_instanceArg, contextArg, autoConnectArg, callbackArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.connectGatt2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val contextArg = args[1] as android.content.Context
            val autoConnectArg = args[2] as Boolean
            val callbackArg = args[3] as android.bluetooth.BluetoothGattCallback
            val transportArg = args[4] as Long
            val wrapped: List<Any?> = try {
              listOf(api.connectGatt2(pigeon_instanceArg, contextArg, autoConnectArg, callbackArg, transportArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.connectGatt3", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val contextArg = args[1] as android.content.Context
            val autoConnectArg = args[2] as Boolean
            val callbackArg = args[3] as android.bluetooth.BluetoothGattCallback
            val transportArg = args[4] as Long
            val phyArg = args[5] as Long
            val wrapped: List<Any?> = try {
              listOf(api.connectGatt3(pigeon_instanceArg, contextArg, autoConnectArg, callbackArg, transportArg, phyArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.connectGatt4", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val contextArg = args[1] as android.content.Context
            val autoConnectArg = args[2] as Boolean
            val callbackArg = args[3] as android.bluetooth.BluetoothGattCallback
            val transportArg = args[4] as Long
            val phyArg = args[5] as Long
            val handlerArg = args[6] as android.os.Handler
            val wrapped: List<Any?> = try {
              listOf(api.connectGatt4(pigeon_instanceArg, contextArg, autoConnectArg, callbackArg, transportArg, phyArg, handlerArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.createBond", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.createBond(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.createInsecureL2capChannel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val psmArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.createInsecureL2capChannel(pigeon_instanceArg, psmArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.createInsecureRfcommSocketToServiceRecord", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val uuidArg = args[1] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.createInsecureRfcommSocketToServiceRecord(pigeon_instanceArg, uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.createL2capChannel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val psmArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.createL2capChannel(pigeon_instanceArg, psmArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.createRfcommSocketToServiceRecord", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val uuidArg = args[1] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.createRfcommSocketToServiceRecord(pigeon_instanceArg, uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.fetchUuidsWithSdp", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.fetchUuidsWithSdp(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.getAddressType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.getAddressType(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.getAlias", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.getAlias(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.getBluetoothClass", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.getBluetoothClass(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.getBondState", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.getBondState(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.getName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.getName(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.getType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.getType(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.getUuids", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.getUuids(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.setAlias", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val aliasArg = args[1] as String?
            val wrapped: List<Any?> = try {
              listOf(api.setAlias(pigeon_instanceArg, aliasArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.setPairingConfirmation", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val confirmArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.setPairingConfirmation(pigeon_instanceArg, confirmArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.setPin", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothDevice
            val pinArg = args[1] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.setPin(pigeon_instanceArg, pinArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothDevice and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothDevice, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothDevice.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Public API for the Bluetooth GATT Profile.
 *
 * This class provides Bluetooth GATT functionality to enable communication with
 * Bluetooth Smart or Smart Ready devices.
 *
 * To connect to a remote peripheral device, create a BluetoothGattCallback and
 * call android.bluetooth.BluetoothDevice#connectGatt to get a instance of this
 * class. GATT capable devices can be discovered using the Bluetooth device
 * discovery or BLE scan process.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothGatt(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Cancels a reliable write transaction for a given device.
   *
   * Calling this function will discard all queued characteristic write operations
   * for a given remote device.
   */
  abstract fun abortReliableWrite(pigeon_instance: android.bluetooth.BluetoothGatt)

  /**
   * Initiates a reliable write transaction for a given remote device.
   *
   * Once a reliable write transaction has been initiated, all calls to
   * #writeCharacteristic are sent to the remote device for verification and
   * queued up for atomic execution. The application will receive a
   * BluetoothGattCallback.onCharacteristicWrite callback in response to every
   * writeCharacteristic(android.bluetooth.BluetoothGattCharacteristic,byte[],int)
   * call and is responsible for verifying if the value has been transmitted
   * accurately.
   *
   * After all characteristics have been queued up and verified, executeReliableWrite
   * will execute all writes. If a characteristic was not written correctly,
   * calling #abortReliableWrite will cancel the current transaction without
   * committing any values on the remote device.
   */
  abstract fun beginReliableWrite(pigeon_instance: android.bluetooth.BluetoothGatt): Boolean

  /**
   * Close this Bluetooth GATT client.
   *
   * Application should call this method as early as possible after it is done with this GATT client.
   */
  abstract fun close(pigeon_instance: android.bluetooth.BluetoothGatt)

  /**
   * Connect back to remote device.
   *
   * This method is used to re-connect to a remote device after the connection
   * has been dropped. If the device is not in range, the re-connection will be
   * triggered once the device is back in range.
   */
  abstract fun connect(pigeon_instance: android.bluetooth.BluetoothGatt): Boolean

  /**
   * Disconnects an established connection, or cancels a connection attempt
   * currently in progress.
   */
  abstract fun disconnect(pigeon_instance: android.bluetooth.BluetoothGatt)

  /**
   * Discovers services offered by a remote device as well as their characteristics
   * and descriptors.
   *
   * This is an asynchronous operation. Once service discovery is completed, the
   * android.bluetooth.BluetoothGattCallback#onServicesDiscovered callback is
   * triggered. If the discovery was successful, the remote services can be
   * retrieved using the getServices function.
   */
  abstract fun discoverServices(pigeon_instance: android.bluetooth.BluetoothGatt): Boolean

  /**
   * Executes a reliable write transaction for a given remote device.
   *
   * This function will commit all queued up characteristic write operations for
   * a given remote device.
   *
   * A BluetoothGattCallback.onReliableWriteCompleted callback is invoked to
   * indicate whether the transaction has been executed correctly.
   */
  abstract fun executeReliableWrite(pigeon_instance: android.bluetooth.BluetoothGatt): Boolean

  /** Return the remote bluetooth device this GATT client targets to */
  abstract fun getDevice(pigeon_instance: android.bluetooth.BluetoothGatt): android.bluetooth.BluetoothDevice

  /**
   * Returns a BluetoothGattService, if the requested UUID is supported by the
   * remote device.
   *
   * This function requires that service discovery has been completed for the
   * given device.
   *
   * If multiple instances of the same service (as identified by UUID) exist,
   * the first instance of the service is returned.
   */
  abstract fun getService(pigeon_instance: android.bluetooth.BluetoothGatt, uuid: java.util.UUID): android.bluetooth.BluetoothGattService

  /**
   * Returns a list of GATT services offered by the remote device.
   *
   * This function requires that service discovery has been completed for the
   * given device.
   */
  abstract fun getServices(pigeon_instance: android.bluetooth.BluetoothGatt): List<android.bluetooth.BluetoothGattService>

  /**
   * Reads the requested characteristic from the associated remote device.
   *
   * This is an asynchronous operation. The result of the read operation is
   * reported by the BluetoothGattCallback.onCharacteristicRead(BluetoothGatt,
   * BluetoothGattCharacteristic, callback.
   */
  abstract fun readCharacteristic(pigeon_instance: android.bluetooth.BluetoothGatt, characteristic: android.bluetooth.BluetoothGattCharacteristic): Boolean

  /**
   * Reads the value for a given descriptor from the associated remote device.
   *
   * Once the read operation has been completed, the
   * android.bluetooth.BluetoothGattCallback#onDescriptorRead callback is triggered,
   * signaling the result of the operation.
   */
  abstract fun readDescriptor(pigeon_instance: android.bluetooth.BluetoothGatt, descriptor: android.bluetooth.BluetoothGattDescriptor): Boolean

  /**
   * Read the current transmitter PHY and receiver PHY of the connection. The
   * values are returned in BluetoothGattCallback.onPhyRead
   */
  abstract fun readPhy(pigeon_instance: android.bluetooth.BluetoothGatt)

  /**
   * Read the RSSI for a connected remote device.
   *
   * The BluetoothGattCallback.onReadRemoteRssi callback will be invoked when
   * the RSSI value has been read.
   */
  abstract fun readRemoteRssi(pigeon_instance: android.bluetooth.BluetoothGatt): Boolean

  /**
   * Request a connection parameter update.
   *
   * This function will send a connection parameter update request to the remote
   * device.
   */
  abstract fun requestConnectionPriority(pigeon_instance: android.bluetooth.BluetoothGatt, connectionPriority: Long): Boolean

  /**
   * Request an MTU size used for a given connection. Please note that starting
   * from Android 14, the Android Bluetooth stack requests the BLE ATT MTU to
   * 517 bytes when the first GATT client requests an MTU, and disregards all
   * subsequent MTU requests. Check out MTU is set to 517 for the first GATT
   * client requesting an MTU for more information.
   *
   * When performing a write request operation (write without response), the data
   * sent is truncated to the MTU size. This function may be used to request a
   * larger MTU size to be able to send more data at once.
   *
   * A BluetoothGattCallback.onMtuChanged callback will indicate whether this
   * operation was successful.
   */
  abstract fun requestMtu(pigeon_instance: android.bluetooth.BluetoothGatt, mtu: Long): Boolean

  /**
   * Enable or disable notifications/indications for a given characteristic.
   *
   * Once notifications are enabled for a characteristic, a
   * android.bluetooth.BluetoothGattCallback#onCharacteristicChanged(android.bluetooth.BluetoothGatt,android.bluetooth.BluetoothGattCharacteristic,byte[])
   * callback will be triggered if the remote device indicates that the given
   * characteristic has changed.
   */
  abstract fun setCharacteristicNotification(pigeon_instance: android.bluetooth.BluetoothGatt, characteristic: android.bluetooth.BluetoothGattCharacteristic, enable: Boolean): Boolean

  /**
   * Set the preferred connection PHY for this app. Please note that this is just
   * a recommendation, whether the PHY change will happen depends on other
   * applications preferences, local and remote controller capabilities. Controller
   * can override these settings.
   *
   * BluetoothGattCallback.onPhyUpdate will be triggered as a result of this
   * call, even if no PHY change happens. It is also triggered when remote device
   * updates the PHY.
   */
  abstract fun setPreferredPhy(pigeon_instance: android.bluetooth.BluetoothGatt, txPhy: Long, rxPhy: Long, phyOptions: Long)

  /**
   * Writes a given characteristic and its values to the associated remote device.
   *
   * Once the write operation has been completed, the
   * android.bluetooth.BluetoothGattCallback#onCharacteristicWrite callback is
   * invoked, reporting the result of the operation.
   */
  abstract fun writeCharacteristic1(pigeon_instance: android.bluetooth.BluetoothGatt, characteristic: android.bluetooth.BluetoothGattCharacteristic): Boolean

  /**
   * Writes a given characteristic and its values to the associated remote device.
   *
   * Once the write operation has been completed, the
   * android.bluetooth.BluetoothGattCallback#onCharacteristicWrite callback is
   * invoked, reporting the result of the operation.
   */
  abstract fun writeCharacteristic2(pigeon_instance: android.bluetooth.BluetoothGatt, characteristic: android.bluetooth.BluetoothGattCharacteristic, value: ByteArray, writeType: Long): Long

  /**
   * Write the value of a given descriptor to the associated remote device.
   *
   * A BluetoothGattCallback.onDescriptorWrite callback is triggered to report
   * the result of the write operation.
   */
  abstract fun writeDescriptor1(pigeon_instance: android.bluetooth.BluetoothGatt, descriptor: android.bluetooth.BluetoothGattDescriptor): Boolean

  /**
   * Write the value of a given descriptor to the associated remote device.
   *
   * A BluetoothGattCallback.onDescriptorWrite callback is triggered to report
   * the result of the write operation.
   */
  abstract fun writeDescriptor2(pigeon_instance: android.bluetooth.BluetoothGatt, descriptor: android.bluetooth.BluetoothGattDescriptor, value: ByteArray): Long

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothGatt?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.abortReliableWrite", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              api.abortReliableWrite(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.beginReliableWrite", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              listOf(api.beginReliableWrite(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.close", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              api.close(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.connect", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              listOf(api.connect(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.disconnect", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              api.disconnect(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.discoverServices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              listOf(api.discoverServices(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.executeReliableWrite", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              listOf(api.executeReliableWrite(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.getDevice", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              listOf(api.getDevice(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.getService", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val uuidArg = args[1] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.getService(pigeon_instanceArg, uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.getServices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              listOf(api.getServices(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.readCharacteristic", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val characteristicArg = args[1] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.readCharacteristic(pigeon_instanceArg, characteristicArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.readDescriptor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val descriptorArg = args[1] as android.bluetooth.BluetoothGattDescriptor
            val wrapped: List<Any?> = try {
              listOf(api.readDescriptor(pigeon_instanceArg, descriptorArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.readPhy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              api.readPhy(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.readRemoteRssi", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val wrapped: List<Any?> = try {
              listOf(api.readRemoteRssi(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.requestConnectionPriority", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val connectionPriorityArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.requestConnectionPriority(pigeon_instanceArg, connectionPriorityArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.requestMtu", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val mtuArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.requestMtu(pigeon_instanceArg, mtuArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.setCharacteristicNotification", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val characteristicArg = args[1] as android.bluetooth.BluetoothGattCharacteristic
            val enableArg = args[2] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.setCharacteristicNotification(pigeon_instanceArg, characteristicArg, enableArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.setPreferredPhy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val txPhyArg = args[1] as Long
            val rxPhyArg = args[2] as Long
            val phyOptionsArg = args[3] as Long
            val wrapped: List<Any?> = try {
              api.setPreferredPhy(pigeon_instanceArg, txPhyArg, rxPhyArg, phyOptionsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.writeCharacteristic1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val characteristicArg = args[1] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.writeCharacteristic1(pigeon_instanceArg, characteristicArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.writeCharacteristic2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val characteristicArg = args[1] as android.bluetooth.BluetoothGattCharacteristic
            val valueArg = args[2] as ByteArray
            val writeTypeArg = args[3] as Long
            val wrapped: List<Any?> = try {
              listOf(api.writeCharacteristic2(pigeon_instanceArg, characteristicArg, valueArg, writeTypeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.writeDescriptor1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val descriptorArg = args[1] as android.bluetooth.BluetoothGattDescriptor
            val wrapped: List<Any?> = try {
              listOf(api.writeDescriptor1(pigeon_instanceArg, descriptorArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.writeDescriptor2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGatt
            val descriptorArg = args[1] as android.bluetooth.BluetoothGattDescriptor
            val valueArg = args[2] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.writeDescriptor2(pigeon_instanceArg, descriptorArg, valueArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothGatt and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothGatt, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGatt.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** This abstract class is used to implement BluetoothGatt callbacks. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothGattCallback(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.BluetoothGattCallback

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothGattCallback?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothGattCallback and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of BluetoothGattCallback, but the class has a nonnull callback method.", "")))
    }
  }

  /** Callback triggered as a result of a remote characteristic notification. */
  fun onCharacteristicChanged1(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, characteristicArg: android.bluetooth.BluetoothGattCharacteristic, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onCharacteristicChanged1"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, characteristicArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered as a result of a remote characteristic notification. Note
   * that the value within the characteristic object may have changed since
   * receiving the remote characteristic notification, so check the parameter
   * value for the value at the time of notification.
   */
  fun onCharacteristicChanged2(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, characteristicArg: android.bluetooth.BluetoothGattCharacteristic, valueArg: ByteArray, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onCharacteristicChanged2"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, characteristicArg, valueArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback reporting the result of a characteristic read operation. */
  fun onCharacteristicRead1(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, characteristicArg: android.bluetooth.BluetoothGattCharacteristic, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onCharacteristicRead1"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, characteristicArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback reporting the result of a characteristic read operation. */
  fun onCharacteristicRead2(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, characteristicArg: android.bluetooth.BluetoothGattCharacteristic, valueArg: ByteArray, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onCharacteristicRead2"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, characteristicArg, valueArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback indicating the result of a characteristic write operation.
   *
   * If this callback is invoked while a reliable write transaction is in progress,
   * the value of the characteristic represents the value reported by the remote
   * device. An application should compare this value to the desired value to be
   * written. If the values don't match, the application must abort the reliable
   * write transaction.
   */
  fun onCharacteristicWrite(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, characteristicArg: android.bluetooth.BluetoothGattCharacteristic, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onCharacteristicWrite"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, characteristicArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback indicating when GATT client has connected/disconnected to/from a
   * remote GATT server.
   */
  fun onConnectionStateChange(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, statusArg: Long, newStateArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onConnectionStateChange"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, statusArg, newStateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback triggered as a result of a remote descriptor read operation. */
  fun onDescriptorRead1(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, descriptorArg: android.bluetooth.BluetoothGattDescriptor, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onDescriptorRead1"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, descriptorArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback reporting the result of a descriptor read operation. */
  fun onDescriptorRead2(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, descriptorArg: android.bluetooth.BluetoothGattDescriptor, statusArg: Long, valueArg: ByteArray, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onDescriptorRead2"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, descriptorArg, statusArg, valueArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback triggered as a result of a remote descriptor write operation. */
  fun onDescriptorWrite(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, descriptorArg: android.bluetooth.BluetoothGattDescriptor, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onDescriptorWrite"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, descriptorArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback indicating the MTU for a given device connection has changed.
   *
   * This callback is triggered in response to the BluetoothGatt.requestMtu
   * function, or in response to a connection event.
   */
  fun onMtuChanged(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, mtuArg: Long, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onMtuChanged"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, mtuArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback triggered as result of BluetoothGatt.readPhy */
  fun onPhyRead(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, txPhyArg: Long, rxPhyArg: Long, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onPhyRead"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, txPhyArg, rxPhyArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered as result of BluetoothGatt.setPreferredPhy, or as a result
   * of remote device changing the PHY.
   */
  fun onPhyUpdate(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, txPhyArg: Long, rxPhyArg: Long, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onPhyUpdate"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, txPhyArg, rxPhyArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback reporting the RSSI for a remote device connection.
   *
   * This callback is triggered in response to the BluetoothGatt.readRemoteRssi
   * function.
   */
  fun onReadRemoteRssi(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, rssiArg: Long, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onReadRemoteRssi"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, rssiArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback invoked when a reliable write transaction has been completed. */
  fun onReliableWriteCompleted(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onReliableWriteCompleted"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback indicating service changed event is received
   *
   * Receiving this event means that the GATT database is out of sync with the
   * remote device. BluetoothGatt.discoverServices should be called to re-discover
   * the services.
   */
  fun onServiceChanged(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onServiceChanged"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback invoked when the list of remote services, characteristics and
   * descriptors for the remote device have been updated, ie new services have
   * been discovered.
   */
  fun onServicesDiscovered(pigeon_instanceArg: android.bluetooth.BluetoothGattCallback, gattArg: android.bluetooth.BluetoothGatt, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCallback.onServicesDiscovered"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, gattArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Represents a Bluetooth GATT Characteristic
 *
 * A GATT characteristic is a basic data element used to construct a GATT service,
 * BluetoothGattService. The characteristic contains a value as well as additional
 * information and optional GATT descriptors, BluetoothGattDescriptor.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothGattCharacteristic(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Create a new BluetoothGattCharacteristic. */
  abstract fun pigeon_defaultConstructor(uuid: java.util.UUID, properties: Long, permissions: Long): android.bluetooth.BluetoothGattCharacteristic

  /** Adds a descriptor to this characteristic. */
  abstract fun addDescriptor(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, descriptor: android.bluetooth.BluetoothGattDescriptor): Boolean

  /**
   * Returns a descriptor with a given UUID out of the list of descriptors for
   * this characteristic.
   */
  abstract fun getDescriptor(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, uuid: java.util.UUID): android.bluetooth.BluetoothGattDescriptor?

  /** Returns a list of descriptors for this characteristic. */
  abstract fun getDescriptors(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic): List<android.bluetooth.BluetoothGattDescriptor>

  /**
   * Return the stored value of this characteristic.
   *
   * See getValue for details.
   */
  abstract fun getFloatValue(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, formatType: Long, offset: Long): Double

  /**
   * Returns the instance ID for this characteristic.
   *
   * If a remote device offers multiple characteristics with the same UUID, the
   * instance ID is used to distuinguish between characteristics.
   */
  abstract fun getInstanceId(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic): Long

  /**
   * Return the stored value of this characteristic.
   *
   * The formatType parameter determines how the characteristic value is to be
   * interpreted. For example, setting formatType to FORMAT_UINT16 specifies that
   * the first two bytes of the characteristic value at the given offset are
   * interpreted to generate the return value.
   */
  abstract fun getIntValue(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, formatType: Long, offset: Long): Long

  /** Returns the permissions for this characteristic. */
  abstract fun getPermissions(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic): Long

  /**
   * Returns the properties of this characteristic.
   *
   * The properties contain a bit mask of property flags indicating the features
   * of this characteristic.
   */
  abstract fun getProperties(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic): Long

  /** Returns the service this characteristic belongs to. */
  abstract fun getService(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic): android.bluetooth.BluetoothGattService

  /** Return the stored value of this characteristic. */
  abstract fun getStringValue(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, offset: Long): String

  /** Returns the UUID of this characteristic */
  abstract fun getUuid(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic): java.util.UUID

  /**
   * Get the stored value for this characteristic.
   *
   * This function returns the stored value for this characteristic as retrieved
   * by calling BluetoothGatt.readCharacteristic. The cached value of the
   * characteristic is updated as a result of a read characteristic operation or
   * if a characteristic update notification has been received.
   */
  abstract fun getValue(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic): ByteArray

  /** Gets the write type for this characteristic. */
  abstract fun getWriteType(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic): Long

  /**
   * Updates the locally stored value of this characteristic.
   *
   * This function modifies the locally stored cached value of this characteristic.
   * To send the value to the remote device, call android.bluetooth.BluetoothGatt#writeCharacteristic
   * to send the value to the remote device.
   */
  abstract fun setValue1(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, value: ByteArray): Boolean

  /**
   * Set the locally stored value of this characteristic.
   *
   * See setValue(byte[]) for details.
   */
  abstract fun setValue2(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, value: Long, formatType: Long, offset: Long): Boolean

  /**
   * Set the locally stored value of this characteristic.
   *
   * See setValue(byte[]) for details.
   */
  abstract fun setValue3(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, mantissa: Long, exponent: Long, formatType: Long, offset: Long): Boolean

  /**
   * Set the locally stored value of this characteristic.
   *
   * See setValue(byte[]) for details.
   */
  abstract fun setValue4(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, value: String): Boolean

  /**
   * Set the write type for this characteristic
   *
   * Setting the write type of a characteristic determines how the
   * android.bluetooth.BluetoothGatt#writeCharacteristic(android.bluetooth.BluetoothGattCharacteristic,byte[],int)
   * function write this characteristic.
   */
  abstract fun setWriteType(pigeon_instance: android.bluetooth.BluetoothGattCharacteristic, writeType: Long)

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothGattCharacteristic?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val uuidArg = args[1] as java.util.UUID
            val propertiesArg = args[2] as Long
            val permissionsArg = args[3] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(uuidArg,propertiesArg,permissionsArg), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.addDescriptor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val descriptorArg = args[1] as android.bluetooth.BluetoothGattDescriptor
            val wrapped: List<Any?> = try {
              listOf(api.addDescriptor(pigeon_instanceArg, descriptorArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getDescriptor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val uuidArg = args[1] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.getDescriptor(pigeon_instanceArg, uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getDescriptors", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.getDescriptors(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getFloatValue", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val formatTypeArg = args[1] as Long
            val offsetArg = args[2] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getFloatValue(pigeon_instanceArg, formatTypeArg, offsetArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getInstanceId", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.getInstanceId(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getIntValue", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val formatTypeArg = args[1] as Long
            val offsetArg = args[2] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getIntValue(pigeon_instanceArg, formatTypeArg, offsetArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getPermissions", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.getPermissions(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getProperties", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.getProperties(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getService", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.getService(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getStringValue", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val offsetArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getStringValue(pigeon_instanceArg, offsetArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.getUuid(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getValue", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.getValue(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.getWriteType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.getWriteType(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.setValue1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val valueArg = args[1] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.setValue1(pigeon_instanceArg, valueArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.setValue2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val valueArg = args[1] as Long
            val formatTypeArg = args[2] as Long
            val offsetArg = args[3] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setValue2(pigeon_instanceArg, valueArg, formatTypeArg, offsetArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.setValue3", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val mantissaArg = args[1] as Long
            val exponentArg = args[2] as Long
            val formatTypeArg = args[3] as Long
            val offsetArg = args[4] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setValue3(pigeon_instanceArg, mantissaArg, exponentArg, formatTypeArg, offsetArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.setValue4", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val valueArg = args[1] as String
            val wrapped: List<Any?> = try {
              listOf(api.setValue4(pigeon_instanceArg, valueArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.setWriteType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattCharacteristic
            val writeTypeArg = args[1] as Long
            val wrapped: List<Any?> = try {
              api.setWriteType(pigeon_instanceArg, writeTypeArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothGattCharacteristic and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothGattCharacteristic, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattCharacteristic.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Represents a Bluetooth GATT Descriptor
 *
 * GATT Descriptors contain additional information and attributes of a GATT
 * characteristic, BluetoothGattCharacteristic. They can be used to describe the
 * characteristic's features or to control certain behaviours of the characteristic.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothGattDescriptor(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Create a new BluetoothGattDescriptor. */
  abstract fun pigeon_defaultConstructor(uuid: java.util.UUID, permissions: Long): android.bluetooth.BluetoothGattDescriptor

  /** Returns the characteristic this descriptor belongs to. */
  abstract fun getCharacteristic(pigeon_instance: android.bluetooth.BluetoothGattDescriptor): android.bluetooth.BluetoothGattCharacteristic

  /** Returns the permissions for this descriptor. */
  abstract fun getPermissions(pigeon_instance: android.bluetooth.BluetoothGattDescriptor): Long

  /** Returns the UUID of this descriptor. */
  abstract fun getUuid(pigeon_instance: android.bluetooth.BluetoothGattDescriptor): java.util.UUID

  /**
   * Returns the stored value for this descriptor
   *
   * This function returns the stored value for this descriptor as retrieved by
   * calling android.bluetooth.BluetoothGatt#readDescriptor. The cached value of
   * the descriptor is updated as a result of a descriptor read operation.
   */
  abstract fun getValue(pigeon_instance: android.bluetooth.BluetoothGattDescriptor): ByteArray

  /**
   * Updates the locally stored value of this descriptor.
   *
   * This function modifies the locally stored cached value of this descriptor.
   * To send the value to the remote device, call android.bluetooth.BluetoothGatt#writeDescriptor
   * to send the value to the remote device.
   */
  abstract fun setValue(pigeon_instance: android.bluetooth.BluetoothGattDescriptor, value: ByteArray): Boolean

  abstract fun disableNotificationValue(): ByteArray

  abstract fun enableIndicationValue(): ByteArray

  abstract fun enableNotificationValue(): ByteArray

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothGattDescriptor?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val uuidArg = args[1] as java.util.UUID
            val permissionsArg = args[2] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(uuidArg,permissionsArg), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.getCharacteristic", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattDescriptor
            val wrapped: List<Any?> = try {
              listOf(api.getCharacteristic(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.getPermissions", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattDescriptor
            val wrapped: List<Any?> = try {
              listOf(api.getPermissions(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.getUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattDescriptor
            val wrapped: List<Any?> = try {
              listOf(api.getUuid(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.getValue", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattDescriptor
            val wrapped: List<Any?> = try {
              listOf(api.getValue(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.setValue", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattDescriptor
            val valueArg = args[1] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.setValue(pigeon_instanceArg, valueArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.disableNotificationValue", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.disableNotificationValue())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.enableIndicationValue", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.enableIndicationValue())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.enableNotificationValue", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.enableNotificationValue())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothGattDescriptor and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothGattDescriptor, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattDescriptor.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Public API for the Bluetooth GATT Profile server role.
 *
 * This class provides Bluetooth GATT server role functionality, allowing
 * applications to create Bluetooth Smart services and characteristics.
 *
 * BluetoothGattServer is a proxy object for controlling the Bluetooth Service
 * via IPC. Use BluetoothManager.openGattServer to get an instance of this class.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothGattServer(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Add a service to the list of services to be hosted.
   *
   * Once a service has been added to the list, the service and its included
   * characteristics will be provided by the local device.
   *
   * If the local device has already exposed services when this function is
   * called, a service update notification will be sent to all clients.
   *
   * The BluetoothGattServerCallback.onServiceAdded callback will indicate whether
   * this service has been added successfully. Do not add another service before
   * this callback.
   */
  abstract fun addService(pigeon_instance: android.bluetooth.BluetoothGattServer, service: android.bluetooth.BluetoothGattService): Boolean

  /**
   * Disconnects an established connection, or cancels a connection attempt
   * currently in progress.
   */
  abstract fun cancelConnection(pigeon_instance: android.bluetooth.BluetoothGattServer, device: android.bluetooth.BluetoothDevice)

  /** Remove all services from the list of provided services. */
  abstract fun clearServices(pigeon_instance: android.bluetooth.BluetoothGattServer)

  /** Close this GATT server instance. */
  abstract fun close(pigeon_instance: android.bluetooth.BluetoothGattServer)

  /**
   * Initiate a connection to a Bluetooth GATT capable device.
   *
   * The connection may not be established right away, but will be completed when
   * the remote device is available. A BluetoothGattServerCallback.onConnectionStateChange
   * callback will be invoked when the connection state changes as a result of
   * this function.
   *
   * The autoConnect parameter determines whether to actively connect to the
   * remote device, or rather passively scan and finalize the connection when
   * the remote device is in range/available. Generally, the first ever connection
   * to a device should be direct (autoConnect set to false) and subsequent
   * connections to known devices should be invoked with the autoConnect parameter
   * set to true.
   */
  abstract fun connect(pigeon_instance: android.bluetooth.BluetoothGattServer, device: android.bluetooth.BluetoothDevice, autoConnect: Boolean): Boolean

  /**
   * Returns a BluetoothGattService from the list of services offered by this
   * device.
   *
   * If multiple instances of the same service (as identified by UUID) exist,
   * the first instance of the service is returned.
   */
  abstract fun getService(pigeon_instance: android.bluetooth.BluetoothGattServer, uuid: java.util.UUID): android.bluetooth.BluetoothGattService

  /**
   * Returns a list of GATT services offered by this device.
   *
   * An application must call addService to add a service to the list of services
   * offered by this device.
   */
  abstract fun getServices(pigeon_instance: android.bluetooth.BluetoothGattServer): List<android.bluetooth.BluetoothGattService>

  /**
   * Send a notification or indication that a local characteristic has been
   * updated.
   *
   * A notification or indication is sent to the remote device to signal that
   * the characteristic has been updated. This function should be invoked for
   * every client that requests notifications/indications by writing to the
   * "Client Configuration" descriptor for the given characteristic.
   */
  abstract fun notifyCharacteristicChanged(pigeon_instance: android.bluetooth.BluetoothGattServer, device: android.bluetooth.BluetoothDevice, characteristic: android.bluetooth.BluetoothGattCharacteristic, confirm: Boolean): Boolean

  /**
   * Send a notification or indication that a local characteristic has been
   * updated.
   *
   * A notification or indication is sent to the remote device to signal that
   * the characteristic has been updated. This function should be invoked for
   * every client that requests notifications/indications by writing to the
   * "Client Configuration" descriptor for the given characteristic.
   */
  abstract fun notifyCharacteristicChanged1(pigeon_instance: android.bluetooth.BluetoothGattServer, device: android.bluetooth.BluetoothDevice, characteristic: android.bluetooth.BluetoothGattCharacteristic, confirm: Boolean, value: ByteArray): Long

  /**
   * Read the current transmitter PHY and receiver PHY of the connection. The
   * values are returned in BluetoothGattServerCallback.onPhyRead
   */
  abstract fun readPhy(pigeon_instance: android.bluetooth.BluetoothGattServer, device: android.bluetooth.BluetoothDevice)

  /** Removes a service from the list of services to be provided. */
  abstract fun removeService(pigeon_instance: android.bluetooth.BluetoothGattServer, service: android.bluetooth.BluetoothGattService): Boolean

  /**
   * Send a response to a read or write request to a remote device.
   *
   * This function must be invoked in when a remote read/write request is received
   * by one of these callback methods:
   *
   * * BluetoothGattServerCallback.onCharacteristicReadRequest
   * * BluetoothGattServerCallback.onCharacteristicWriteRequest
   * * BluetoothGattServerCallback.onDescriptorReadRequest
   * * BluetoothGattServerCallback.onDescriptorWriteRequest
   */
  abstract fun sendResponse(pigeon_instance: android.bluetooth.BluetoothGattServer, device: android.bluetooth.BluetoothDevice, requestId: Long, status: Long, offset: Long, value: ByteArray): Boolean

  /**
   * Set the preferred connection PHY for this app. Please note that this is just
   * a recommendation, whether the PHY change will happen depends on other
   * applications preferences, local and remote controller capabilities. Controller
   * can override these settings.
   *
   * BluetoothGattServerCallback.onPhyUpdate will be triggered as a result of
   * this call, even if no PHY change happens. It is also triggered when remote
   * device updates the PHY.
   */
  abstract fun setPreferredPhy(pigeon_instance: android.bluetooth.BluetoothGattServer, device: android.bluetooth.BluetoothDevice, txPhy: Long, rxPhy: Long, phyOptions: Long)

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothGattServer?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.addService", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val serviceArg = args[1] as android.bluetooth.BluetoothGattService
            val wrapped: List<Any?> = try {
              listOf(api.addService(pigeon_instanceArg, serviceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.cancelConnection", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              api.cancelConnection(pigeon_instanceArg, deviceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.clearServices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val wrapped: List<Any?> = try {
              api.clearServices(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.close", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val wrapped: List<Any?> = try {
              api.close(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.connect", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val autoConnectArg = args[2] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.connect(pigeon_instanceArg, deviceArg, autoConnectArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.getService", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val uuidArg = args[1] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.getService(pigeon_instanceArg, uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.getServices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val wrapped: List<Any?> = try {
              listOf(api.getServices(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.notifyCharacteristicChanged", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val characteristicArg = args[2] as android.bluetooth.BluetoothGattCharacteristic
            val confirmArg = args[3] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.notifyCharacteristicChanged(pigeon_instanceArg, deviceArg, characteristicArg, confirmArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.notifyCharacteristicChanged1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val characteristicArg = args[2] as android.bluetooth.BluetoothGattCharacteristic
            val confirmArg = args[3] as Boolean
            val valueArg = args[4] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.notifyCharacteristicChanged1(pigeon_instanceArg, deviceArg, characteristicArg, confirmArg, valueArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.readPhy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              api.readPhy(pigeon_instanceArg, deviceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.removeService", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val serviceArg = args[1] as android.bluetooth.BluetoothGattService
            val wrapped: List<Any?> = try {
              listOf(api.removeService(pigeon_instanceArg, serviceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.sendResponse", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val requestIdArg = args[2] as Long
            val statusArg = args[3] as Long
            val offsetArg = args[4] as Long
            val valueArg = args[5] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.sendResponse(pigeon_instanceArg, deviceArg, requestIdArg, statusArg, offsetArg, valueArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.setPreferredPhy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattServer
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val txPhyArg = args[2] as Long
            val rxPhyArg = args[3] as Long
            val phyOptionsArg = args[4] as Long
            val wrapped: List<Any?> = try {
              api.setPreferredPhy(pigeon_instanceArg, deviceArg, txPhyArg, rxPhyArg, phyOptionsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothGattServer and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothGattServer, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServer.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** This abstract class is used to implement BluetoothGattServer callbacks. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothGattServerCallback(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.BluetoothGattServerCallback

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothGattServerCallback?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothGattServerCallback and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of BluetoothGattServerCallback, but the class has a nonnull callback method.", "")))
    }
  }

  /**
   * A remote client has requested to read a local characteristic.
   *
   * An application must call BluetoothGattServer.sendResponse to complete the
   * request.
   */
  fun onCharacteristicReadRequest(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, requestIdArg: Long, offsetArg: Long, characteristicArg: android.bluetooth.BluetoothGattCharacteristic, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onCharacteristicReadRequest"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, requestIdArg, offsetArg, characteristicArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * A remote client has requested to write to a local characteristic.
   *
   * An application must call BluetoothGattServer.sendResponse to complete the
   * request.
   */
  fun onCharacteristicWriteRequest(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, requestIdArg: Long, characteristicArg: android.bluetooth.BluetoothGattCharacteristic, preparedWriteArg: Boolean, responseNeededArg: Boolean, offsetArg: Long, valueArg: ByteArray, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onCharacteristicWriteRequest"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, requestIdArg, characteristicArg, preparedWriteArg, responseNeededArg, offsetArg, valueArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback indicating when a remote device has been connected or disconnected. */
  fun onConnectionStateChange(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, statusArg: Long, newStateArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onConnectionStateChange"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, statusArg, newStateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * A remote client has requested to read a local descriptor.
   *
   * An application must call BluetoothGattServer.sendResponse to complete the
   * request.
   */
  fun onDescriptorReadRequest(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, requestIdArg: Long, offsetArg: Long, descriptorArg: android.bluetooth.BluetoothGattDescriptor, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onDescriptorReadRequest"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, requestIdArg, offsetArg, descriptorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * A remote client has requested to write to a local descriptor.
   *
   * An application must call BluetoothGattServer.sendResponse to complete the
   * request.
   */
  fun onDescriptorWriteRequest(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, requestIdArg: Long, descriptorArg: android.bluetooth.BluetoothGattDescriptor, preparedWriteArg: Boolean, responseNeededArg: Boolean, offsetArg: Long, valueArg: ByteArray, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onDescriptorWriteRequest"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, requestIdArg, descriptorArg, preparedWriteArg, responseNeededArg, offsetArg, valueArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Execute all pending write operations for this device.
   *
   * An application must call BluetoothGattServer.sendResponse to complete the
   * request.
   */
  fun onExecuteWrite(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, requestIdArg: Long, executeArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onExecuteWrite"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, requestIdArg, executeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback indicating the MTU for a given device connection has changed.
   *
   * This callback will be invoked if a remote client has requested to change
   * the MTU for a given connection.
   */
  fun onMtuChanged(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, mtuArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onMtuChanged"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, mtuArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback invoked when a notification or indication has been sent to a remote
   * device.
   *
   * When multiple notifications are to be sent, an application must wait for
   * this callback to be received before sending additional notifications.
   */
  fun onNotificationSent(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onNotificationSent"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback triggered as result of BluetoothGattServer.readPhy */
  fun onPhyRead(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, txPhyArg: Long, rxPhyArg: Long, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onPhyRead"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, txPhyArg, rxPhyArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered as result of BluetoothGattServer.setPreferredPhy, or as
   * a result of remote device changing the PHY.
   */
  fun onPhyUpdate(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, deviceArg: android.bluetooth.BluetoothDevice, txPhyArg: Long, rxPhyArg: Long, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onPhyUpdate"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, txPhyArg, rxPhyArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Indicates whether a local service has been added successfully. */
  fun onServiceAdded(pigeon_instanceArg: android.bluetooth.BluetoothGattServerCallback, statusArg: Long, serviceArg: android.bluetooth.BluetoothGattService, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattServerCallback.onServiceAdded"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, statusArg, serviceArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Represents a Bluetooth GATT Service
 *
 * Gatt Service contains a collection of BluetoothGattCharacteristic, as well as
 * referenced services.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothGattService(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Create a new BluetoothGattService. */
  abstract fun pigeon_defaultConstructor(uuid: java.util.UUID, serviceType: Long): android.bluetooth.BluetoothGattService

  /** Add a characteristic to this service. */
  abstract fun addCharacteristic(pigeon_instance: android.bluetooth.BluetoothGattService, characteristic: android.bluetooth.BluetoothGattCharacteristic): Boolean

  /** Add an included service to this service. */
  abstract fun addService(pigeon_instance: android.bluetooth.BluetoothGattService, service: android.bluetooth.BluetoothGattService): Boolean

  /**
   * Returns a characteristic with a given UUID out of the list of characteristics
   * offered by this service.
   *
   * This is a convenience function to allow access to a given characteristic
   * without enumerating over the list returned by getCharacteristics manually.
   *
   * If a remote service offers multiple characteristics with the same UUID, the
   * first instance of a characteristic with the given UUID is returned.
   */
  abstract fun getCharacteristic(pigeon_instance: android.bluetooth.BluetoothGattService, uuid: java.util.UUID): android.bluetooth.BluetoothGattCharacteristic?

  /** Returns a list of characteristics included in this service. */
  abstract fun getCharacteristics(pigeon_instance: android.bluetooth.BluetoothGattService): List<android.bluetooth.BluetoothGattCharacteristic>

  /** Get the list of included GATT services for this service. */
  abstract fun getIncludedServices(pigeon_instance: android.bluetooth.BluetoothGattService): List<android.bluetooth.BluetoothGattService>

  /**
   * Returns the instance ID for this service
   *
   * If a remote device offers multiple services with the same UUID (ex. multiple
   * battery services for different batteries), the instance ID is used to
   * distuinguish services.
   */
  abstract fun getInstanceId(pigeon_instance: android.bluetooth.BluetoothGattService): Long

  /** Get the type of this service (primary/secondary) */
  abstract fun getType(pigeon_instance: android.bluetooth.BluetoothGattService): Long

  /** Returns the UUID of this service */
  abstract fun getUuid(pigeon_instance: android.bluetooth.BluetoothGattService): java.util.UUID

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothGattService?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val uuidArg = args[1] as java.util.UUID
            val serviceTypeArg = args[2] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(uuidArg,serviceTypeArg), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.addCharacteristic", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattService
            val characteristicArg = args[1] as android.bluetooth.BluetoothGattCharacteristic
            val wrapped: List<Any?> = try {
              listOf(api.addCharacteristic(pigeon_instanceArg, characteristicArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.addService", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattService
            val serviceArg = args[1] as android.bluetooth.BluetoothGattService
            val wrapped: List<Any?> = try {
              listOf(api.addService(pigeon_instanceArg, serviceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.getCharacteristic", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattService
            val uuidArg = args[1] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.getCharacteristic(pigeon_instanceArg, uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.getCharacteristics", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattService
            val wrapped: List<Any?> = try {
              listOf(api.getCharacteristics(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.getIncludedServices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattService
            val wrapped: List<Any?> = try {
              listOf(api.getIncludedServices(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.getInstanceId", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattService
            val wrapped: List<Any?> = try {
              listOf(api.getInstanceId(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.getType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattService
            val wrapped: List<Any?> = try {
              listOf(api.getType(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.getUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothGattService
            val wrapped: List<Any?> = try {
              listOf(api.getUuid(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothGattService and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothGattService, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothGattService.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * High level manager used to obtain an instance of an BluetoothAdapter and to
 * conduct overall Bluetooth Management.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothManager(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Get the BluetoothAdapter for this device. */
  abstract fun getAdapter(pigeon_instance: android.bluetooth.BluetoothManager): android.bluetooth.BluetoothAdapter

  /**
   * Get connected devices for the specified profile.
   *
   * Return the set of devices which are in state BluetoothProfile.STATE_CONNECTED
   *
   * This is not specific to any application configuration but represents the
   * connection state of Bluetooth for this profile. This can be used by applications
   * like status bar which would just like to know the state of Bluetooth.
   */
  abstract fun getConnectedDevices(pigeon_instance: android.bluetooth.BluetoothManager, profile: Long): List<android.bluetooth.BluetoothDevice>

  /**
   * Get the current connection state of the profile to the remote device.
   *
   * This is not specific to any application configuration but represents the
   * connection state of the local Bluetooth adapter for certain profile. This
   * can be used by applications like status bar which would just like to know
   * the state of Bluetooth.
   */
  abstract fun getConnectionState(pigeon_instance: android.bluetooth.BluetoothManager, device: android.bluetooth.BluetoothDevice, profile: Long): Long

  /**
   * Get a list of devices that match any of the given connection states.
   *
   * If none of the devices match any of the given states, an empty list will be
   * returned.
   *
   * This is not specific to any application configuration but represents the
   * connection state of the local Bluetooth adapter for this profile. This can
   * be used by applications like status bar which would just like to know the
   * state of the local adapter.
   */
  abstract fun getDevicesMatchingConnectionStates(pigeon_instance: android.bluetooth.BluetoothManager, profile: Long, states: List<Long>): List<android.bluetooth.BluetoothDevice>

  /**
   * Open a GATT Server The callback is used to deliver results to Caller, such
   * as connection status as well as the results of any other GATT server
   * operations. The method returns a BluetoothGattServer instance. You can use
   * BluetoothGattServer to conduct GATT server operations.
   */
  abstract fun openGattServer(pigeon_instance: android.bluetooth.BluetoothManager, context: android.content.Context, callback: android.bluetooth.BluetoothGattServerCallback): android.bluetooth.BluetoothGattServer

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothManager?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothManager.getAdapter", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothManager
            val wrapped: List<Any?> = try {
              listOf(api.getAdapter(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothManager.getConnectedDevices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothManager
            val profileArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getConnectedDevices(pigeon_instanceArg, profileArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothManager.getConnectionState", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothManager
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val profileArg = args[2] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getConnectionState(pigeon_instanceArg, deviceArg, profileArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothManager.getDevicesMatchingConnectionStates", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothManager
            val profileArg = args[1] as Long
            val statesArg = args[2] as List<Long>
            val wrapped: List<Any?> = try {
              listOf(api.getDevicesMatchingConnectionStates(pigeon_instanceArg, profileArg, statesArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothManager.openGattServer", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothManager
            val contextArg = args[1] as android.content.Context
            val callbackArg = args[2] as android.bluetooth.BluetoothGattServerCallback
            val wrapped: List<Any?> = try {
              listOf(api.openGattServer(pigeon_instanceArg, contextArg, callbackArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothManager and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothManager, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothManager.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * A listening Bluetooth socket.
 *
 * The interface for Bluetooth Sockets is similar to that of TCP sockets:
 * java.net.Socket and java.net.ServerSocket. On the server side, use a
 * BluetoothServerSocket to create a listening server socket. When a connection
 * is accepted by the BluetoothServerSocket, it will return a new BluetoothSocket
 * to manage the connection. On the client side, use a single BluetoothSocket to
 * both initiate an outgoing connection and to manage the connection.
 *
 * For Bluetooth BR/EDR, the most common type of socket is RFCOMM, which is the
 * type supported by the Android APIs. RFCOMM is a connection-oriented, streaming
 * transport over Bluetooth BR/EDR. It is also known as the Serial Port Profile
 * (SPP). To create a listening BluetoothServerSocket that's ready for incoming
 * Bluetooth BR/EDR connections, use BluetoothAdapter.listenUsingRfcommWithServiceRecord().
 *
 * For Bluetooth LE, the socket uses LE Connection-oriented Channel (CoC). LE
 * CoC is a connection-oriented, streaming transport over Bluetooth LE and has
 * a credit-based flow control. Correspondingly, use BluetoothAdapter.listenUsingL2capChannel()
 * to create a listening BluetoothServerSocket that's ready for incoming Bluetooth
 * LE CoC connections. For LE CoC, you can use getPsm() to get the protocol/service
 * multiplexer (PSM) value that the peer needs to use to connect to your socket.
 *
 * After the listening BluetoothServerSocket is created, call accept() to listen
 * for incoming connection requests. This call will block until a connection is
 * established, at which point, it will return a BluetoothSocket to manage the
 * connection. Once the BluetoothSocket is acquired, it's a good idea to call
 * #close() on the BluetoothServerSocket when it's no longer needed for accepting
 * connections. Closing the BluetoothServerSocket will not close the returned
 * BluetoothSocket.
 *
 * BluetoothServerSocket is thread safe. In particular, #close will always
 * immediately abort ongoing operations and close the server socket.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothServerSocket(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Block until a connection is established.
   *
   * Returns a connected BluetoothSocket on successful connection.
   *
   * Once this call returns, it can be called again to accept subsequent incoming connections.
   *
   * close can be used to abort this call from another thread.
   */
  abstract fun accept1(pigeon_instance: android.bluetooth.BluetoothServerSocket): android.bluetooth.BluetoothSocket

  /**
   * Block until a connection is established, with timeout.
   *
   * Returns a connected BluetoothSocket on successful connection.
   *
   * Once this call returns, it can be called again to accept subsequent incoming
   * connections.
   *
   * close can be used to abort this call from another thread.
   */
  abstract fun accept2(pigeon_instance: android.bluetooth.BluetoothServerSocket, timeout: Long): android.bluetooth.BluetoothSocket

  /**
   * Immediately close this socket, and release all associated resources.
   *
   * Causes blocked calls on this socket in other threads to immediately throw
   * an IOException.
   *
   * Closing the BluetoothServerSocket will not close any BluetoothSocket received
   * from accept().
   */
  abstract fun close(pigeon_instance: android.bluetooth.BluetoothServerSocket)

  /**
   * Returns the assigned dynamic protocol/service multiplexer (PSM) value for
   * the listening L2CAP Connection-oriented Channel (CoC) server socket. This
   * server socket must be returned by the BluetoothAdapter.listenUsingL2capChannel()
   * or android.bluetooth.BluetoothAdapter#listenUsingInsecureL2capChannel().
   * The returned value is undefined if this method is called on non-L2CAP server
   * sockets.
   */
  abstract fun getPsm(pigeon_instance: android.bluetooth.BluetoothServerSocket): Long

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothServerSocket?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothServerSocket.accept1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothServerSocket
            val wrapped: List<Any?> = try {
              listOf(api.accept1(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothServerSocket.accept2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothServerSocket
            val timeoutArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.accept2(pigeon_instanceArg, timeoutArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothServerSocket.close", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothServerSocket
            val wrapped: List<Any?> = try {
              api.close(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothServerSocket.getPsm", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothServerSocket
            val wrapped: List<Any?> = try {
              listOf(api.getPsm(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothServerSocket and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothServerSocket, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothServerSocket.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * A connected or connecting Bluetooth socket.
 *
 * The interface for Bluetooth Sockets is similar to that of TCP sockets:
 * java.net.Socket and java.net.ServerSocket. On the server side, use a
 * BluetoothServerSocket to create a listening server socket. When a connection
 * is accepted by the BluetoothServerSocket, it will return a new BluetoothSocket
 * to manage the connection. On the client side, use a single BluetoothSocket to
 * both initiate an outgoing connection and to manage the connection.
 *
 * The most common type of Bluetooth socket is RFCOMM, which is the type supported
 * by the Android APIs. RFCOMM is a connection-oriented, streaming transport over
 * Bluetooth. It is also known as the Serial Port Profile (SPP).
 *
 * To create a BluetoothSocket for connecting to a known device, use
 * BluetoothDevice.createRfcommSocketToServiceRecord(). Then call connect() to
 * attempt a connection to the remote device. This call will block until a
 * connection is established or the connection fails.
 *
 * To create a BluetoothSocket as a server (or "host"), see the BluetoothServerSocket
 * documentation.
 *
 * Once the socket is connected, whether initiated as a client or accepted as a
 * server, open the IO streams by calling getInputStream and getOutputStream in
 * order to retrieve java.io.InputStream and java.io.OutputStream objects,
 * respectively, which are automatically connected to the socket.
 *
 * BluetoothSocket is thread safe. In particular, #close will always immediately
 * abort ongoing operations and close the socket.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothSocket(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun close(pigeon_instance: android.bluetooth.BluetoothSocket)

  /**
   * Attempt to connect to a remote device.
   *
   * This method will block until a connection is made or the connection fails.
   * If this method returns without an exception then this socket is now connected.
   *
   * Creating new connections to remote Bluetooth devices should not be attempted
   * while device discovery is in progress. Device discovery is a heavyweight
   * procedure on the Bluetooth adapter and will significantly slow a device
   * connection. Use android.bluetooth.BluetoothAdapter#cancelDiscovery() to
   * cancel an ongoing discovery. Discovery is not managed by the Activity, but
   * is run as a system service, so an application should always call
   * android.bluetooth.BluetoothAdapter#cancelDiscovery() even if it did not
   * directly request a discovery, just to be sure.
   *
   * close can be used to abort this call from another thread.
   *
   * Requires the android.Manifest.permission#BLUETOOTH_PRIVILEGED permission
   * only when mDataPath is different from android.bluetooth.BluetoothSocketSettings#DATA_PATH_NO_OFFLOAD.
   */
  abstract fun connect(pigeon_instance: android.bluetooth.BluetoothSocket)

  /** Get the type of the underlying connection. */
  abstract fun getConnectionType(pigeon_instance: android.bluetooth.BluetoothSocket): Long

  /**
   * Get the input stream associated with this socket.
   *
   * The input stream will be returned even if the socket is not yet connected,
   * but operations on that stream will throw IOException until the associated
   * socket is connected.
   */
  abstract fun getInputStream(pigeon_instance: android.bluetooth.BluetoothSocket): java.io.InputStream

  /**
   * Get the maximum supported Receive packet size for the underlying transport.
   * Use this to optimize the reads done on the input stream, as any call to read
   * will return a maximum of this amount of bytes - or for some transports a
   * multiple of this value.
   */
  abstract fun getMaxReceivePacketSize(pigeon_instance: android.bluetooth.BluetoothSocket): Long

  /**
   * Get the maximum supported Transmit packet size for the underlying transport.
   * Use this to optimize the writes done to the output socket, to avoid sending
   * half full packets.
   */
  abstract fun getMaxTransmitPacketSize(pigeon_instance: android.bluetooth.BluetoothSocket): Long

  /**
   * Get the output stream associated with this socket.
   *
   * The output stream will be returned even if the socket is not yet connected,
   * but operations on that stream will throw IOException until the associated
   * socket is connected.
   */
  abstract fun getOutputStream(pigeon_instance: android.bluetooth.BluetoothSocket): java.io.OutputStream

  /** Get the remote device this socket is connecting, or connected, to. */
  abstract fun getRemoteDevice(pigeon_instance: android.bluetooth.BluetoothSocket): android.bluetooth.BluetoothDevice

  /**
   * Get the connection status of this socket, ie, whether there is an active
   * connection with remote device.
   */
  abstract fun isConnected(pigeon_instance: android.bluetooth.BluetoothSocket): Boolean

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothSocket?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.close", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              api.close(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.connect", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              api.connect(pigeon_instanceArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.getConnectionType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              listOf(api.getConnectionType(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.getInputStream", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              listOf(api.getInputStream(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.getMaxReceivePacketSize", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              listOf(api.getMaxReceivePacketSize(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.getMaxTransmitPacketSize", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              listOf(api.getMaxTransmitPacketSize(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.getOutputStream", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              listOf(api.getOutputStream(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.getRemoteDevice", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              listOf(api.getRemoteDevice(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.isConnected", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothSocket
            val wrapped: List<Any?> = try {
              listOf(api.isConnected(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothSocket and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothSocket, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothSocket.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** Callback interface used to deliver LE scan results. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiLeScanCallback(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.BluetoothAdapter.LeScanCallback

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiLeScanCallback?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.LeScanCallback.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of LeScanCallback and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothAdapter.LeScanCallback, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of LeScanCallback, but the class has a nonnull callback method.", "")))
    }
  }

  fun onLeScan(pigeon_instanceArg: android.bluetooth.BluetoothAdapter.LeScanCallback, deviceArg: android.bluetooth.BluetoothDevice, rssiArg: Long, scanRecordArg: ByteArray, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.LeScanCallback.onLeScan"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, deviceArg, rssiArg, scanRecordArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

}
/**
 * Public APIs for the Bluetooth Profiles.
 *
 * Clients should call BluetoothAdapter.getProfileProxy, to get the Profile Proxy.
 * Each public profile with this interface.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothProfile(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun getConnectedDevices(pigeon_instance: android.bluetooth.BluetoothProfile): List<android.bluetooth.BluetoothDevice>

  abstract fun getConnectionState(pigeon_instance: android.bluetooth.BluetoothProfile, device: android.bluetooth.BluetoothDevice): Long

  abstract fun getDevicesMatchingConnectionStates(pigeon_instance: android.bluetooth.BluetoothProfile, states: List<Long>): List<android.bluetooth.BluetoothDevice>

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothProfile?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothProfile.getConnectedDevices", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothProfile
            val wrapped: List<Any?> = try {
              listOf(api.getConnectedDevices(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothProfile.getConnectionState", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothProfile
            val deviceArg = args[1] as android.bluetooth.BluetoothDevice
            val wrapped: List<Any?> = try {
              listOf(api.getConnectionState(pigeon_instanceArg, deviceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothProfile.getDevicesMatchingConnectionStates", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.BluetoothProfile
            val statesArg = args[1] as List<Long>
            val wrapped: List<Any?> = try {
              listOf(api.getDevicesMatchingConnectionStates(pigeon_instanceArg, statesArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothProfile and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothProfile, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothProfile.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

}
/**
 * An interface for notifying BluetoothProfile IPC clients when they have been
 * connected or disconnected to the service.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiServiceListener(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.BluetoothProfile.ServiceListener

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiServiceListener?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ServiceListener.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ServiceListener and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.BluetoothProfile.ServiceListener, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of ServiceListener, but the class has a nonnull callback method.", "")))
    }
  }

  /**
   * Called to notify the client when the proxy object has been connected to the
   * service.
   */
  fun onServiceConnected(pigeon_instanceArg: android.bluetooth.BluetoothProfile.ServiceListener, profileArg: Long, proxyArg: android.bluetooth.BluetoothProfile, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ServiceListener.onServiceConnected"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, profileArg, proxyArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Called to notify the client that this proxy object has been disconnected
   * from the service.
   */
  fun onServiceDisconnected(pigeon_instanceArg: android.bluetooth.BluetoothProfile.ServiceListener, profileArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ServiceListener.onServiceDisconnected"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, profileArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

}
/**
 * Bluetooth LE advertising callbacks, used to deliver advertising operation
 * status.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertiseCallback(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.AdvertiseCallback

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertiseCallback?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseCallback.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertiseCallback and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertiseCallback, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of AdvertiseCallback, but the class has a nonnull callback method.", "")))
    }
  }

  /** Callback when advertising could not be started. */
  fun onStartFailure(pigeon_instanceArg: android.bluetooth.le.AdvertiseCallback, errorCodeArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseCallback.onStartFailure"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, errorCodeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to android.bluetooth.le.BluetoothLeAdvertiser#startAdvertising
   * indicating that the advertising has been started successfully.
   */
  fun onStartSuccess(pigeon_instanceArg: android.bluetooth.le.AdvertiseCallback, settingsInEffectArg: android.bluetooth.le.AdvertiseSettings, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseCallback.onStartSuccess"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, settingsInEffectArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Advertise data packet container for Bluetooth LE advertising. This represents the data to be advertised as well as the scan response data for active scans.
 *
 * Use AdvertiseData.Builder to create an instance of AdvertiseData to be advertised.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertiseData(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Whether the device name will be included in the advertisement packet. */
  abstract fun getIncludeDeviceName(pigeon_instance: android.bluetooth.le.AdvertiseData): Boolean

  /**
   * Whether the transmission power level will be included in the advertisement
   * packet.
   */
  abstract fun getIncludeTxPowerLevel(pigeon_instance: android.bluetooth.le.AdvertiseData): Boolean

  /**
   * Returns an array of manufacturer Id and the corresponding manufacturer
   * specific data. The manufacturer id is a non-negative number assigned by
   * Bluetooth SIG.
   */
  abstract fun getManufacturerSpecificData(pigeon_instance: android.bluetooth.le.AdvertiseData): Map<Long, ByteArray>

  /** Returns a map of 16-bit UUID and its corresponding service data. */
  abstract fun getServiceData(pigeon_instance: android.bluetooth.le.AdvertiseData): Map<android.os.ParcelUuid, ByteArray>

  /**
   * Returns a list of service solicitation UUIDs within the advertisement that
   * we invite to connect.
   */
  abstract fun getServiceSolicitationUuids(pigeon_instance: android.bluetooth.le.AdvertiseData): List<android.os.ParcelUuid>

  /**
   * Returns a list of service UUIDs within the advertisement that are used to
   * identify the Bluetooth GATT services.
   */
  abstract fun getServiceUuids(pigeon_instance: android.bluetooth.le.AdvertiseData): List<android.os.ParcelUuid>

  /** Returns a list of TransportDiscoveryData within the advertisement. */
  @androidx.annotation.RequiresApi(api = 33)
  abstract fun getTransportDiscoveryData(pigeon_instance: android.bluetooth.le.AdvertiseData): List<android.bluetooth.le.TransportDiscoveryData>

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertiseData?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.getIncludeDeviceName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData
            val wrapped: List<Any?> = try {
              listOf(api.getIncludeDeviceName(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.getIncludeTxPowerLevel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData
            val wrapped: List<Any?> = try {
              listOf(api.getIncludeTxPowerLevel(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.getManufacturerSpecificData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData
            val wrapped: List<Any?> = try {
              listOf(api.getManufacturerSpecificData(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.getServiceData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData
            val wrapped: List<Any?> = try {
              listOf(api.getServiceData(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.getServiceSolicitationUuids", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData
            val wrapped: List<Any?> = try {
              listOf(api.getServiceSolicitationUuids(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.getServiceUuids", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData
            val wrapped: List<Any?> = try {
              listOf(api.getServiceUuids(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 33) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.getTransportDiscoveryData", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData
              val wrapped: List<Any?> = try {
                listOf(api.getTransportDiscoveryData(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.getTransportDiscoveryData",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.TransportDiscoveryData`, which requires api version 33."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertiseData and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertiseData, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseData.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** Builder for AdvertiseData. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertiseDataBuilder(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.AdvertiseData.Builder

  /**
   * Add manufacturer specific data.
   *
   * Please refer to the Bluetooth Assigned Numbers document provided by the
   * Bluetooth SIG for a list of existing company identifiers.
   */
  abstract fun addManufacturerData(pigeon_instance: android.bluetooth.le.AdvertiseData.Builder, manufacturerId: Long, manufacturerSpecificData: ByteArray): android.bluetooth.le.AdvertiseData.Builder

  /** Add service data to advertise data. */
  abstract fun addServiceData(pigeon_instance: android.bluetooth.le.AdvertiseData.Builder, serviceDataUuid: android.os.ParcelUuid, serviceData: ByteArray): android.bluetooth.le.AdvertiseData.Builder

  /** Add a service solicitation UUID to advertise data. */
  abstract fun addServiceSolicitationUuid(pigeon_instance: android.bluetooth.le.AdvertiseData.Builder, serviceSolicitationUuid: android.os.ParcelUuid): android.bluetooth.le.AdvertiseData.Builder

  /** Add a service UUID to advertise data. */
  abstract fun addServiceUuid(pigeon_instance: android.bluetooth.le.AdvertiseData.Builder, serviceUuid: android.os.ParcelUuid): android.bluetooth.le.AdvertiseData.Builder

  /** Add Transport Discovery Data to advertise data. */
  @androidx.annotation.RequiresApi(api = 33)
  abstract fun addTransportDiscoveryData(pigeon_instance: android.bluetooth.le.AdvertiseData.Builder, transportDiscoveryData: android.bluetooth.le.TransportDiscoveryData): android.bluetooth.le.AdvertiseData.Builder

  /** Build the AdvertiseData. */
  abstract fun build(pigeon_instance: android.bluetooth.le.AdvertiseData.Builder): android.bluetooth.le.AdvertiseData

  /** Set whether the device name should be included in advertise packet. */
  abstract fun setIncludeDeviceName(pigeon_instance: android.bluetooth.le.AdvertiseData.Builder, includeDeviceName: Boolean): android.bluetooth.le.AdvertiseData.Builder

  /**
   * Whether the transmission power level should be included in the advertise
   * packet. Tx power level field takes 3 bytes in advertise packet.
   */
  abstract fun setIncludeTxPowerLevel(pigeon_instance: android.bluetooth.le.AdvertiseData.Builder, includeTxPowerLevel: Boolean): android.bluetooth.le.AdvertiseData.Builder

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertiseDataBuilder?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.addManufacturerData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData.Builder
            val manufacturerIdArg = args[1] as Long
            val manufacturerSpecificDataArg = args[2] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.addManufacturerData(pigeon_instanceArg, manufacturerIdArg, manufacturerSpecificDataArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.addServiceData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData.Builder
            val serviceDataUuidArg = args[1] as android.os.ParcelUuid
            val serviceDataArg = args[2] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.addServiceData(pigeon_instanceArg, serviceDataUuidArg, serviceDataArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.addServiceSolicitationUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData.Builder
            val serviceSolicitationUuidArg = args[1] as android.os.ParcelUuid
            val wrapped: List<Any?> = try {
              listOf(api.addServiceSolicitationUuid(pigeon_instanceArg, serviceSolicitationUuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.addServiceUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData.Builder
            val serviceUuidArg = args[1] as android.os.ParcelUuid
            val wrapped: List<Any?> = try {
              listOf(api.addServiceUuid(pigeon_instanceArg, serviceUuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 33) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.addTransportDiscoveryData", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData.Builder
              val transportDiscoveryDataArg = args[1] as android.bluetooth.le.TransportDiscoveryData
              val wrapped: List<Any?> = try {
                listOf(api.addTransportDiscoveryData(pigeon_instanceArg, transportDiscoveryDataArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.addTransportDiscoveryData",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.TransportDiscoveryData`, which requires api version 33."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.build", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData.Builder
            val wrapped: List<Any?> = try {
              listOf(api.build(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.setIncludeDeviceName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData.Builder
            val includeDeviceNameArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.setIncludeDeviceName(pigeon_instanceArg, includeDeviceNameArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.setIncludeTxPowerLevel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseData.Builder
            val includeTxPowerLevelArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.setIncludeTxPowerLevel(pigeon_instanceArg, includeTxPowerLevelArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertiseDataBuilder and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertiseData.Builder, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseDataBuilder.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * The AdvertiseSettings provide a way to adjust advertising preferences for each
 * Bluetooth LE advertisement instance. Use AdvertiseSettings.Builder to create
 * an instance of this class.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertiseSettings(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Returns the advertise mode. */
  abstract fun getMode(pigeon_instance: android.bluetooth.le.AdvertiseSettings): Long

  /** Returns the advertising time limit in milliseconds. */
  abstract fun getTimeout(pigeon_instance: android.bluetooth.le.AdvertiseSettings): Long

  /** Returns the TX power level for advertising. */
  abstract fun getTxPowerLevel(pigeon_instance: android.bluetooth.le.AdvertiseSettings): Long

  /** Returns whether the advertisement will indicate connectable. */
  abstract fun isConnectable(pigeon_instance: android.bluetooth.le.AdvertiseSettings): Boolean

  /** Returns whether the advertisement will be discoverable. */
  abstract fun isDiscoverable(pigeon_instance: android.bluetooth.le.AdvertiseSettings): Boolean

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertiseSettings?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettings.getMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings
            val wrapped: List<Any?> = try {
              listOf(api.getMode(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettings.getTimeout", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings
            val wrapped: List<Any?> = try {
              listOf(api.getTimeout(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettings.getTxPowerLevel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings
            val wrapped: List<Any?> = try {
              listOf(api.getTxPowerLevel(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettings.isConnectable", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings
            val wrapped: List<Any?> = try {
              listOf(api.isConnectable(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettings.isDiscoverable", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings
            val wrapped: List<Any?> = try {
              listOf(api.isDiscoverable(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertiseSettings and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertiseSettings, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettings.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** Builder class for AdvertiseSettings. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertiseSettingsBuilder(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.AdvertiseSettings.Builder

  /** Build the AdvertiseSettings object. */
  abstract fun build(pigeon_instance: android.bluetooth.le.AdvertiseSettings.Builder): android.bluetooth.le.AdvertiseSettings

  /** Set advertise mode to control the advertising power and latency. */
  abstract fun setAdvertiseMode(pigeon_instance: android.bluetooth.le.AdvertiseSettings.Builder, advertiseMode: Long): android.bluetooth.le.AdvertiseSettings.Builder

  /** Set whether the advertisement type should be connectable or non-connectable. */
  abstract fun setConnectable(pigeon_instance: android.bluetooth.le.AdvertiseSettings.Builder, connectable: Boolean): android.bluetooth.le.AdvertiseSettings.Builder

  /** Set whether the advertisement type should be discoverable or non-discoverable. */
  abstract fun setDiscoverable(pigeon_instance: android.bluetooth.le.AdvertiseSettings.Builder, discoverable: Boolean): android.bluetooth.le.AdvertiseSettings.Builder

  /** Limit advertising to a given amount of time. */
  abstract fun setTimeout(pigeon_instance: android.bluetooth.le.AdvertiseSettings.Builder, timeoutMillis: Long): android.bluetooth.le.AdvertiseSettings.Builder

  /**
   * Set advertise TX power level to control the transmission power level for
   * the advertising.
   */
  abstract fun setTxPowerLevel(pigeon_instance: android.bluetooth.le.AdvertiseSettings.Builder, txPowerLevel: Long): android.bluetooth.le.AdvertiseSettings.Builder

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertiseSettingsBuilder?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettingsBuilder.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettingsBuilder.build", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings.Builder
            val wrapped: List<Any?> = try {
              listOf(api.build(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettingsBuilder.setAdvertiseMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings.Builder
            val advertiseModeArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setAdvertiseMode(pigeon_instanceArg, advertiseModeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettingsBuilder.setConnectable", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings.Builder
            val connectableArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.setConnectable(pigeon_instanceArg, connectableArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettingsBuilder.setDiscoverable", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings.Builder
            val discoverableArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.setDiscoverable(pigeon_instanceArg, discoverableArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettingsBuilder.setTimeout", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings.Builder
            val timeoutMillisArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setTimeout(pigeon_instanceArg, timeoutMillisArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettingsBuilder.setTxPowerLevel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertiseSettings.Builder
            val txPowerLevelArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setTxPowerLevel(pigeon_instanceArg, txPowerLevelArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertiseSettingsBuilder and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertiseSettings.Builder, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertiseSettingsBuilder.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * This class provides a way to control single Bluetooth LE advertising instance.
 *
 * To get an instance of AdvertisingSet, call the
 * android.bluetooth.le.BluetoothLeAdvertiser#startAdvertisingSet method.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertisingSet(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Enables Advertising. This method returns immediately, the operation status
   * is delivered through callback.onAdvertisingEnabled().
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun enableAdvertising(pigeon_instance: android.bluetooth.le.AdvertisingSet, enable: Boolean, duration: Long, maxExtendedAdvertisingEvents: Long)

  /**
   * Set/update data being Advertised. Make sure that data doesn't exceed the
   * size limit for specified AdvertisingSetParameters. This method returns
   * immediately, the operation status is delivered through callback.onAdvertisingDataSet().
   *
   * Advertising data must be empty if non-legacy scannable advertising is used.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setAdvertisingData(pigeon_instance: android.bluetooth.le.AdvertisingSet, advertiseData: android.bluetooth.le.AdvertiseData)

  /**
   * Update advertising parameters associated with this AdvertisingSet. Must be
   * called when advertising is not active. This method returns immediately, the
   * operation status is delivered through callback.onAdvertisingParametersUpdated.
   *
   * Requires the android.Manifest.permission#BLUETOOTH_PRIVILEGED permission
   * when parameters.getOwnAddressType() is different from
   * AdvertisingSetParameters.ADDRESS_TYPE_DEFAULT or parameters.isDirected() is
   * true.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setAdvertisingParameters(pigeon_instance: android.bluetooth.le.AdvertisingSet, parameters: android.bluetooth.le.AdvertisingSetParameters)

  /**
   * Used to set periodic advertising data, must be called after
   * setPeriodicAdvertisingParameters, or after advertising was started with
   * periodic advertising data set. This method returns immediately, the operation
   * status is delivered through callback.onPeriodicAdvertisingDataSet().
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setPeriodicAdvertisingData(pigeon_instance: android.bluetooth.le.AdvertisingSet, periodicData: android.bluetooth.le.AdvertiseData)

  /**
   * Used to enable/disable periodic advertising. This method returns immediately,
   * the operation status is delivered through callback.onPeriodicAdvertisingEnable().
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setPeriodicAdvertisingEnabled(pigeon_instance: android.bluetooth.le.AdvertisingSet, enable: Boolean)

  /**
   * Update periodic advertising parameters associated with this set. Must be
   * called when periodic advertising is not enabled. This method returns
   * immediately, the operation status is delivered through
   * callback.onPeriodicAdvertisingParametersUpdated().
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setPeriodicAdvertisingParameters(pigeon_instance: android.bluetooth.le.AdvertisingSet, parameters: android.bluetooth.le.PeriodicAdvertisingParameters)

  /**
   * Set/update scan response data. Make sure that data doesn't exceed the size
   * limit for specified AdvertisingSetParameters. This method returns immediately,
   * the operation status is delivered through callback.onScanResponseDataSet().
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setScanResponseData(pigeon_instance: android.bluetooth.le.AdvertisingSet, scanResponse: android.bluetooth.le.AdvertiseData)

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertisingSet?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.enableAdvertising", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSet
              val enableArg = args[1] as Boolean
              val durationArg = args[2] as Long
              val maxExtendedAdvertisingEventsArg = args[3] as Long
              val wrapped: List<Any?> = try {
                api.enableAdvertising(pigeon_instanceArg, enableArg, durationArg, maxExtendedAdvertisingEventsArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.enableAdvertising",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSet`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setAdvertisingData", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSet
              val advertiseDataArg = args[1] as android.bluetooth.le.AdvertiseData
              val wrapped: List<Any?> = try {
                api.setAdvertisingData(pigeon_instanceArg, advertiseDataArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setAdvertisingData",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSet`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setAdvertisingParameters", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSet
              val parametersArg = args[1] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                api.setAdvertisingParameters(pigeon_instanceArg, parametersArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setAdvertisingParameters",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setPeriodicAdvertisingData", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSet
              val periodicDataArg = args[1] as android.bluetooth.le.AdvertiseData
              val wrapped: List<Any?> = try {
                api.setPeriodicAdvertisingData(pigeon_instanceArg, periodicDataArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setPeriodicAdvertisingData",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSet`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setPeriodicAdvertisingEnabled", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSet
              val enableArg = args[1] as Boolean
              val wrapped: List<Any?> = try {
                api.setPeriodicAdvertisingEnabled(pigeon_instanceArg, enableArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setPeriodicAdvertisingEnabled",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSet`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setPeriodicAdvertisingParameters", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSet
              val parametersArg = args[1] as android.bluetooth.le.PeriodicAdvertisingParameters
              val wrapped: List<Any?> = try {
                api.setPeriodicAdvertisingParameters(pigeon_instanceArg, parametersArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setPeriodicAdvertisingParameters",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.PeriodicAdvertisingParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setScanResponseData", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSet
              val scanResponseArg = args[1] as android.bluetooth.le.AdvertiseData
              val wrapped: List<Any?> = try {
                api.setScanResponseData(pigeon_instanceArg, scanResponseArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.setScanResponseData",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSet`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertisingSet and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 26)
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertisingSet, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSet.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Bluetooth LE advertising set callbacks, used to deliver advertising operation
 * status.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertisingSetCallback(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.AdvertisingSetCallback

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertisingSetCallback?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.pigeon_defaultConstructor", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_identifierArg = args[0] as Long
              val wrapped: List<Any?> = try {
                api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.pigeon_defaultConstructor",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetCallback`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertisingSetCallback and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 26)
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of AdvertisingSetCallback, but the class has a nonnull callback method.", "")))
    }
  }

  /**
   * Callback triggered in response to AdvertisingSet.setAdvertisingData indicating
   * result of the operation. If status is ADVERTISE_SUCCESS, then data was
   * changed.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onAdvertisingDataSet(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onAdvertisingDataSet"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to android.bluetooth.le.BluetoothLeAdvertiser#startAdvertisingSet
   * indicating result of the operation. If status is ADVERTISE_SUCCESS, then
   * advertising set is advertising.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onAdvertisingEnabled(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, enableArg: Boolean, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onAdvertisingEnabled"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg, enableArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to AdvertisingSet.setAdvertisingParameters
   * indicating result of the operation.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onAdvertisingParametersUpdated(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, txPowerArg: Long, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onAdvertisingParametersUpdated"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg, txPowerArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to android.bluetooth.le.BluetoothLeAdvertiser#startAdvertisingSet
   * indicating result of the operation. If status is ADVERTISE_SUCCESS, then
   * advertisingSet contains the started set and it is advertising. If error
   * occurred, advertisingSet is null, and status will be set to proper error
   * code.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onAdvertisingSetStarted(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, txPowerArg: Long, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onAdvertisingSetStarted"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg, txPowerArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to BluetoothLeAdvertiser.stopAdvertisingSet
   * indicating advertising set is stopped.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onAdvertisingSetStopped(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onAdvertisingSetStopped"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to AdvertisingSet.setPeriodicAdvertisingData
   * indicating result of the operation.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onPeriodicAdvertisingDataSet(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onPeriodicAdvertisingDataSet"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to AdvertisingSet.setPeriodicAdvertisingEnabled
   * indicating result of the operation.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onPeriodicAdvertisingEnabled(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, enableArg: Boolean, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onPeriodicAdvertisingEnabled"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg, enableArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to AdvertisingSet.setPeriodicAdvertisingParameters
   * indicating result of the operation.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onPeriodicAdvertisingParametersUpdated(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onPeriodicAdvertisingParametersUpdated"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /**
   * Callback triggered in response to AdvertisingSet.setAdvertisingData indicating
   * result of the operation.
   */
  @androidx.annotation.RequiresApi(api = 26)
  fun onScanResponseDataSet(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetCallback, advertisingSetArg: android.bluetooth.le.AdvertisingSet, statusArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetCallback.onScanResponseDataSet"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, advertisingSetArg, statusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * The AdvertisingSetParameters provide a way to adjust advertising preferences
 * for each Bluetooth LE advertising set. Use AdvertisingSetParameters.Builder
 * to create an instance of this class.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertisingSetParameters(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Returns the advertising interval. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun getInterval(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Long

  /** Returns the primary advertising phy. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun getPrimaryPhy(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Long

  /** Returns the secondary advertising phy. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun getSecondaryPhy(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Long

  /** Returns the TX power level for advertising. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun getTxPowerLevel(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Long

  /** Returns whether the TX Power will be included. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun includeTxPower(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Boolean

  /** Returns whether the advertisement will be anonymous. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun isAnonymous(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Boolean

  /** Returns whether the advertisement will be connectable. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun isConnectable(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Boolean

  /** Returns whether the advertisement will be discoverable. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun isDiscoverable(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Boolean

  /** Returns whether the legacy advertisement will be used. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun isLegacy(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Boolean

  /** Returns whether the advertisement will be scannable. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun isScannable(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters): Boolean

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertisingSetParameters?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.getInterval", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.getInterval(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.getInterval",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.getPrimaryPhy", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.getPrimaryPhy(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.getPrimaryPhy",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.getSecondaryPhy", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.getSecondaryPhy(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.getSecondaryPhy",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.getTxPowerLevel", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.getTxPowerLevel(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.getTxPowerLevel",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.includeTxPower", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.includeTxPower(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.includeTxPower",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isAnonymous", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.isAnonymous(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isAnonymous",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isConnectable", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.isConnectable(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isConnectable",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isDiscoverable", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.isDiscoverable(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isDiscoverable",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isLegacy", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.isLegacy(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isLegacy",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isScannable", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters
              val wrapped: List<Any?> = try {
                listOf(api.isScannable(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.isScannable",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertisingSetParameters and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 26)
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetParameters, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParameters.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** Builder class for AdvertisingSetParameters. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiAdvertisingSetParametersBuilder(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.AdvertisingSetParameters.Builder

  /** Build the AdvertisingSetParameters object. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun build(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder): android.bluetooth.le.AdvertisingSetParameters

  /**
   * Set whether advertiser address should be omitted from all packets. If this
   * mode is used, periodic advertising can't be enabled for this set.
   *
   * This is used only if legacy mode is not used.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setAnonymous(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, isAnonymous: Boolean): android.bluetooth.le.AdvertisingSetParameters.Builder

  /**
   * Set whether the advertisement type should be connectable or non-connectable.
   * Legacy advertisements can be both connectable and scannable. Non-legacy
   * advertisements can be only scannable or only connectable.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setConnectable(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, connectable: Boolean): android.bluetooth.le.AdvertisingSetParameters.Builder

  /**
   * Set whether the advertisement type should be discoverable or non-discoverable.
   * By default, advertisements will be discoverable. Devices connecting to
   * non-discoverable advertisements cannot initiate bonding.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setDiscoverable(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, discoverable: Boolean): android.bluetooth.le.AdvertisingSetParameters.Builder

  /**
   * Set whether TX power should be included in the extended header.
   *
   * This is used only if legacy mode is not used.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setIncludeTxPower(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, includeTxPower: Boolean): android.bluetooth.le.AdvertisingSetParameters.Builder

  /** Set advertising interval. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setInterval(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, interval: Long): android.bluetooth.le.AdvertisingSetParameters.Builder

  /**
   * When set to true, advertising set will advertise 4.x Spec compliant
   * advertisements.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setLegacyMode(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, isLegacy: Boolean): android.bluetooth.le.AdvertisingSetParameters.Builder

  /**
   * Set the primary physical channel used for this advertising set.
   *
   * This is used only if legacy mode is not used.
   *
   * Use BluetoothAdapter.isLeCodedPhySupported to determine if LE Coded PHY is
   * supported on this device.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setPrimaryPhy(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, primaryPhy: Long): android.bluetooth.le.AdvertisingSetParameters.Builder

  /**
   * Set whether the advertisement type should be scannable. Legacy advertisements
   * can be both connectable and scannable. Non-legacy advertisements can be only
   * scannable or only connectable.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setScannable(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, scannable: Boolean): android.bluetooth.le.AdvertisingSetParameters.Builder

  /**
   * Set the secondary physical channel used for this advertising set.
   *
   * This is used only if legacy mode is not used.
   *
   * Use BluetoothAdapter.isLeCodedPhySupported and android.bluetooth.BluetoothAdapter#isLe2MPhySupported
   * to determine if LE Coded PHY or 2M PHY is supported on this device.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setSecondaryPhy(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, secondaryPhy: Long): android.bluetooth.le.AdvertisingSetParameters.Builder

  /** Set the transmission power level for the advertising. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setTxPowerLevel(pigeon_instance: android.bluetooth.le.AdvertisingSetParameters.Builder, txPowerLevel: Long): android.bluetooth.le.AdvertisingSetParameters.Builder

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiAdvertisingSetParametersBuilder?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.pigeon_defaultConstructor", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_identifierArg = args[0] as Long
              val wrapped: List<Any?> = try {
                api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.pigeon_defaultConstructor",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.build", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val wrapped: List<Any?> = try {
                listOf(api.build(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.build",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setAnonymous", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val isAnonymousArg = args[1] as Boolean
              val wrapped: List<Any?> = try {
                listOf(api.setAnonymous(pigeon_instanceArg, isAnonymousArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setAnonymous",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setConnectable", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val connectableArg = args[1] as Boolean
              val wrapped: List<Any?> = try {
                listOf(api.setConnectable(pigeon_instanceArg, connectableArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setConnectable",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setDiscoverable", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val discoverableArg = args[1] as Boolean
              val wrapped: List<Any?> = try {
                listOf(api.setDiscoverable(pigeon_instanceArg, discoverableArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setDiscoverable",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setIncludeTxPower", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val includeTxPowerArg = args[1] as Boolean
              val wrapped: List<Any?> = try {
                listOf(api.setIncludeTxPower(pigeon_instanceArg, includeTxPowerArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setIncludeTxPower",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setInterval", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val intervalArg = args[1] as Long
              val wrapped: List<Any?> = try {
                listOf(api.setInterval(pigeon_instanceArg, intervalArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setInterval",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setLegacyMode", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val isLegacyArg = args[1] as Boolean
              val wrapped: List<Any?> = try {
                listOf(api.setLegacyMode(pigeon_instanceArg, isLegacyArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setLegacyMode",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setPrimaryPhy", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val primaryPhyArg = args[1] as Long
              val wrapped: List<Any?> = try {
                listOf(api.setPrimaryPhy(pigeon_instanceArg, primaryPhyArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setPrimaryPhy",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setScannable", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val scannableArg = args[1] as Boolean
              val wrapped: List<Any?> = try {
                listOf(api.setScannable(pigeon_instanceArg, scannableArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setScannable",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setSecondaryPhy", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val secondaryPhyArg = args[1] as Long
              val wrapped: List<Any?> = try {
                listOf(api.setSecondaryPhy(pigeon_instanceArg, secondaryPhyArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setSecondaryPhy",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setTxPowerLevel", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.AdvertisingSetParameters.Builder
              val txPowerLevelArg = args[1] as Long
              val wrapped: List<Any?> = try {
                listOf(api.setTxPowerLevel(pigeon_instanceArg, txPowerLevelArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.setTxPowerLevel",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of AdvertisingSetParametersBuilder and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 26)
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.AdvertisingSetParameters.Builder, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.AdvertisingSetParametersBuilder.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * This class provides a way to perform Bluetooth LE advertise operations, such
 * as starting and stopping advertising. An advertiser can broadcast up to 31
 * bytes of advertisement data represented by AdvertiseData.
 *
 * To get an instance of BluetoothLeAdvertiser, call the
 * android.bluetooth.BluetoothAdapter#getBluetoothLeAdvertiser() method.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothLeAdvertiser(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Start Bluetooth LE Advertising. On success, the advertiseData will be
   * broadcasted. Returns immediately, the operation status is delivered through
   * callback.
   *
   * Requires the android.Manifest.permission#BLUETOOTH_PRIVILEGED permission
   * only when settings.getOwnAddressType() is different from
   * AdvertisingSetParameters.ADDRESS_TYPE_DEFAULT.
   *
   * The android.Manifest.permission#BLUETOOTH_ADVERTISE permission is always
   * enforced.
   */
  abstract fun startAdvertising1(pigeon_instance: android.bluetooth.le.BluetoothLeAdvertiser, settings: android.bluetooth.le.AdvertiseSettings, advertiseData: android.bluetooth.le.AdvertiseData, callback: android.bluetooth.le.AdvertiseCallback)

  /**
   * Start Bluetooth LE Advertising. The advertiseData will be broadcasted if
   * the operation succeeds. The scanResponse is returned when a scanning device
   * sends an active scan request. This method returns immediately, the operation
   * status is delivered through callback.
   *
   * Requires the android.Manifest.permission#BLUETOOTH_PRIVILEGED permission
   * only when settings.getOwnAddressType() is different from
   * AdvertisingSetParameters.ADDRESS_TYPE_DEFAULT.
   *
   * The android.Manifest.permission#BLUETOOTH_ADVERTISE permission is always
   * enforced.
   */
  abstract fun startAdvertising2(pigeon_instance: android.bluetooth.le.BluetoothLeAdvertiser, settings: android.bluetooth.le.AdvertiseSettings, advertiseData: android.bluetooth.le.AdvertiseData, scanResponse: android.bluetooth.le.AdvertiseData, callback: android.bluetooth.le.AdvertiseCallback)

  /**
   * Creates a new advertising set. If operation succeed, device will start
   * advertising. This method returns immediately, the operation status is
   * delivered through callback.onAdvertisingSetStarted().
   *
   * Requires the android.Manifest.permission#BLUETOOTH_PRIVILEGED permission
   * when parameters.getOwnAddressType() is different from
   * AdvertisingSetParameters.ADDRESS_TYPE_DEFAULT or parameters.isDirected() is
   * true.
   *
   * The android.Manifest.permission#BLUETOOTH_ADVERTISE permission is always
   * enforced.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun startAdvertisingSet1(pigeon_instance: android.bluetooth.le.BluetoothLeAdvertiser, parameters: android.bluetooth.le.AdvertisingSetParameters, advertiseData: android.bluetooth.le.AdvertiseData, scanResponse: android.bluetooth.le.AdvertiseData, periodicParameters: android.bluetooth.le.PeriodicAdvertisingParameters, periodicData: android.bluetooth.le.AdvertiseData, callback: android.bluetooth.le.AdvertisingSetCallback)

  /**
   * Creates a new advertising set. If operation succeed, device will start
   * advertising. This method returns immediately, the operation status is
   * delivered through callback.onAdvertisingSetStarted().
   *
   * Requires the android.Manifest.permission#BLUETOOTH_PRIVILEGED permission
   * when parameters.getOwnAddressType() is different from
   * AdvertisingSetParameters.ADDRESS_TYPE_DEFAULT or parameters.isDirected() is
   * true.
   *
   * The android.Manifest.permission#BLUETOOTH_ADVERTISE permission is always
   * enforced.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun startAdvertisingSet2(pigeon_instance: android.bluetooth.le.BluetoothLeAdvertiser, parameters: android.bluetooth.le.AdvertisingSetParameters, advertiseData: android.bluetooth.le.AdvertiseData, scanResponse: android.bluetooth.le.AdvertiseData, periodicParameters: android.bluetooth.le.PeriodicAdvertisingParameters, periodicData: android.bluetooth.le.AdvertiseData, duration: Long, maxExtendedAdvertisingEvents: Long, callback: android.bluetooth.le.AdvertisingSetCallback)

  /**
   * Stop Bluetooth LE advertising. The callback must be the same one use in
   * android.bluetooth.le.BluetoothLeAdvertiser#startAdvertising.
   */
  abstract fun stopAdvertising(pigeon_instance: android.bluetooth.le.BluetoothLeAdvertiser, callback: android.bluetooth.le.AdvertiseCallback)

  /**
   * Used to dispose of a AdvertisingSet object, obtained with
   * android.bluetooth.le.BluetoothLeAdvertiser#startAdvertisingSet.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun stopAdvertisingSet(pigeon_instance: android.bluetooth.le.BluetoothLeAdvertiser, callback: android.bluetooth.le.AdvertisingSetCallback)

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothLeAdvertiser?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.startAdvertising1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeAdvertiser
            val settingsArg = args[1] as android.bluetooth.le.AdvertiseSettings
            val advertiseDataArg = args[2] as android.bluetooth.le.AdvertiseData
            val callbackArg = args[3] as android.bluetooth.le.AdvertiseCallback
            val wrapped: List<Any?> = try {
              api.startAdvertising1(pigeon_instanceArg, settingsArg, advertiseDataArg, callbackArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.startAdvertising2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeAdvertiser
            val settingsArg = args[1] as android.bluetooth.le.AdvertiseSettings
            val advertiseDataArg = args[2] as android.bluetooth.le.AdvertiseData
            val scanResponseArg = args[3] as android.bluetooth.le.AdvertiseData
            val callbackArg = args[4] as android.bluetooth.le.AdvertiseCallback
            val wrapped: List<Any?> = try {
              api.startAdvertising2(pigeon_instanceArg, settingsArg, advertiseDataArg, scanResponseArg, callbackArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.startAdvertisingSet1", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeAdvertiser
              val parametersArg = args[1] as android.bluetooth.le.AdvertisingSetParameters
              val advertiseDataArg = args[2] as android.bluetooth.le.AdvertiseData
              val scanResponseArg = args[3] as android.bluetooth.le.AdvertiseData
              val periodicParametersArg = args[4] as android.bluetooth.le.PeriodicAdvertisingParameters
              val periodicDataArg = args[5] as android.bluetooth.le.AdvertiseData
              val callbackArg = args[6] as android.bluetooth.le.AdvertisingSetCallback
              val wrapped: List<Any?> = try {
                api.startAdvertisingSet1(pigeon_instanceArg, parametersArg, advertiseDataArg, scanResponseArg, periodicParametersArg, periodicDataArg, callbackArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.startAdvertisingSet1",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetCallback`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.startAdvertisingSet2", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeAdvertiser
              val parametersArg = args[1] as android.bluetooth.le.AdvertisingSetParameters
              val advertiseDataArg = args[2] as android.bluetooth.le.AdvertiseData
              val scanResponseArg = args[3] as android.bluetooth.le.AdvertiseData
              val periodicParametersArg = args[4] as android.bluetooth.le.PeriodicAdvertisingParameters
              val periodicDataArg = args[5] as android.bluetooth.le.AdvertiseData
              val durationArg = args[6] as Long
              val maxExtendedAdvertisingEventsArg = args[7] as Long
              val callbackArg = args[8] as android.bluetooth.le.AdvertisingSetCallback
              val wrapped: List<Any?> = try {
                api.startAdvertisingSet2(pigeon_instanceArg, parametersArg, advertiseDataArg, scanResponseArg, periodicParametersArg, periodicDataArg, durationArg, maxExtendedAdvertisingEventsArg, callbackArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.startAdvertisingSet2",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetCallback`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.stopAdvertising", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeAdvertiser
            val callbackArg = args[1] as android.bluetooth.le.AdvertiseCallback
            val wrapped: List<Any?> = try {
              api.stopAdvertising(pigeon_instanceArg, callbackArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.stopAdvertisingSet", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeAdvertiser
              val callbackArg = args[1] as android.bluetooth.le.AdvertisingSetCallback
              val wrapped: List<Any?> = try {
                api.stopAdvertisingSet(pigeon_instanceArg, callbackArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.stopAdvertisingSet",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.AdvertisingSetCallback`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothLeAdvertiser and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.BluetoothLeAdvertiser, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeAdvertiser.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * This class provides methods to perform scan related operations for Bluetooth
 * LE devices. An application can scan for a particular type of Bluetooth LE
 * devices using ScanFilter. It can also request different types of callbacks
 * for delivering the result.
 *
 * Use BluetoothAdapter.getBluetoothLeScanner() to get an instance of BluetoothLeScanner.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiBluetoothLeScanner(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Flush pending batch scan results stored in Bluetooth controller. This will
   * return Bluetooth LE scan results batched on bluetooth controller. Returns
   * immediately, batch scan results data will be delivered through the callback.
   */
  abstract fun flushPendingScanResults(pigeon_instance: android.bluetooth.le.BluetoothLeScanner, callback: android.bluetooth.le.ScanCallback)

  /**
   * Start Bluetooth LE scan with default parameters and no filters. The scan
   * results will be delivered through callback. For unfiltered scans, scanning
   * is stopped on screen off to save power. Scanning is resumed when screen is
   * turned on again. To avoid this, use
   * startScan(java.util.List,android.bluetooth.le.ScanSettings,android.bluetooth.le.ScanCallback)
   * with desired ScanFilter.
   *
   * An app must have ACCESS_COARSE_LOCATION permission in order to get results.
   * An App targeting Android Q or later must have ACCESS_FINE_LOCATION permission
   * in order to get results.
   */
  abstract fun startScan1(pigeon_instance: android.bluetooth.le.BluetoothLeScanner, callback: android.bluetooth.le.ScanCallback)

  /**
   * Start Bluetooth LE scan using a PendingIntent. The scan results will be
   * delivered via the PendingIntent. Use this method of scanning if your process
   * is not always running and it should be started when scan results are available.
   *
   * An app must have ACCESS_COARSE_LOCATION permission in order to get results.
   * An App targeting Android Q or later must have ACCESS_FINE_LOCATION permission
   * in order to get results.
   *
   * When the PendingIntent is delivered, the Intent passed to the receiver or
   * activity will contain one or more of the extras EXTRA_CALLBACK_TYPE,
   * EXTRA_ERROR_CODE and EXTRA_LIST_SCAN_RESULT to indicate the result of the
   * scan.
   */
  abstract fun startScan2(pigeon_instance: android.bluetooth.le.BluetoothLeScanner, filters: List<android.bluetooth.le.ScanFilter>?, settings: android.bluetooth.le.ScanSettings?, callbackIntent: android.app.PendingIntent)

  /**
   * Start Bluetooth LE scan. The scan results will be delivered through callback.
   * For unfiltered scans, scanning is stopped on screen off to save power.
   * Scanning is resumed when screen is turned on again. To avoid this, do filtered
   * scanning by using proper ScanFilter.
   *
   * An app must have ACCESS_COARSE_LOCATION permission in order to get results.
   * An App targeting Android Q or later must have ACCESS_FINE_LOCATION permission
   * in order to get results.
   */
  abstract fun startScan3(pigeon_instance: android.bluetooth.le.BluetoothLeScanner, filters: List<android.bluetooth.le.ScanFilter>, settings: android.bluetooth.le.ScanSettings, callback: android.bluetooth.le.ScanCallback)

  /**
   * Stops an ongoing Bluetooth LE scan started using a PendingIntent. When
   * creating the PendingIntent parameter, please do not use the FLAG_CANCEL_CURRENT
   * flag. Otherwise, the stop scan may have no effect.
   */
  abstract fun stopScan1(pigeon_instance: android.bluetooth.le.BluetoothLeScanner, callbackIntent: android.app.PendingIntent)

  /** Stops an ongoing Bluetooth LE scan. */
  abstract fun stopScan2(pigeon_instance: android.bluetooth.le.BluetoothLeScanner, callback: android.bluetooth.le.ScanCallback)

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiBluetoothLeScanner?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeScanner.flushPendingScanResults", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeScanner
            val callbackArg = args[1] as android.bluetooth.le.ScanCallback
            val wrapped: List<Any?> = try {
              api.flushPendingScanResults(pigeon_instanceArg, callbackArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeScanner.startScan1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeScanner
            val callbackArg = args[1] as android.bluetooth.le.ScanCallback
            val wrapped: List<Any?> = try {
              api.startScan1(pigeon_instanceArg, callbackArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeScanner.startScan2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeScanner
            val filtersArg = args[1] as List<android.bluetooth.le.ScanFilter>?
            val settingsArg = args[2] as android.bluetooth.le.ScanSettings?
            val callbackIntentArg = args[3] as android.app.PendingIntent
            val wrapped: List<Any?> = try {
              api.startScan2(pigeon_instanceArg, filtersArg, settingsArg, callbackIntentArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeScanner.startScan3", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeScanner
            val filtersArg = args[1] as List<android.bluetooth.le.ScanFilter>
            val settingsArg = args[2] as android.bluetooth.le.ScanSettings
            val callbackArg = args[3] as android.bluetooth.le.ScanCallback
            val wrapped: List<Any?> = try {
              api.startScan3(pigeon_instanceArg, filtersArg, settingsArg, callbackArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeScanner.stopScan1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeScanner
            val callbackIntentArg = args[1] as android.app.PendingIntent
            val wrapped: List<Any?> = try {
              api.stopScan1(pigeon_instanceArg, callbackIntentArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeScanner.stopScan2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.BluetoothLeScanner
            val callbackArg = args[1] as android.bluetooth.le.ScanCallback
            val wrapped: List<Any?> = try {
              api.stopScan2(pigeon_instanceArg, callbackArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of BluetoothLeScanner and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.BluetoothLeScanner, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.BluetoothLeScanner.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * The PeriodicAdvertisingParameters provide a way to adjust periodic advertising
 * preferences for each Bluetooth LE advertising set. Use PeriodicAdvertisingParameters.Builder
 * to create an instance of this class.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiPeriodicAdvertisingParameters(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Returns whether the TX Power will be included. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun getIncludeTxPower(pigeon_instance: android.bluetooth.le.PeriodicAdvertisingParameters): Boolean

  /**
   * Returns the periodic advertising interval, in 1.25ms unit. Valid values are
   * from 80 (100ms) to 65519 (81.89875s).
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun getInterval(pigeon_instance: android.bluetooth.le.PeriodicAdvertisingParameters): Long

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiPeriodicAdvertisingParameters?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParameters.getIncludeTxPower", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.PeriodicAdvertisingParameters
              val wrapped: List<Any?> = try {
                listOf(api.getIncludeTxPower(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParameters.getIncludeTxPower",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.PeriodicAdvertisingParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParameters.getInterval", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.PeriodicAdvertisingParameters
              val wrapped: List<Any?> = try {
                listOf(api.getInterval(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParameters.getInterval",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.PeriodicAdvertisingParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of PeriodicAdvertisingParameters and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 26)
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.PeriodicAdvertisingParameters, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParameters.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiPeriodicAdvertisingParametersBuilder(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.PeriodicAdvertisingParameters.Builder

  /** Build the AdvertisingSetParameters object. */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun build(pigeon_instance: android.bluetooth.le.PeriodicAdvertisingParameters.Builder): android.bluetooth.le.PeriodicAdvertisingParameters

  /**
   * Whether the transmission power level should be included in the periodic
   * packet.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setIncludeTxPower(pigeon_instance: android.bluetooth.le.PeriodicAdvertisingParameters.Builder, includeTxPower: Boolean): android.bluetooth.le.PeriodicAdvertisingParameters.Builder

  /**
   * Set advertising interval for periodic advertising, in 1.25ms unit. Valid
   * values are from 80 (100ms) to 65519 (81.89875s). Value from range
   * [interval, interval+20ms] will be picked as the actual value.
   */
  @androidx.annotation.RequiresApi(api = 26)
  abstract fun setInterval(pigeon_instance: android.bluetooth.le.PeriodicAdvertisingParameters.Builder, interval: Long): android.bluetooth.le.PeriodicAdvertisingParameters.Builder

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiPeriodicAdvertisingParametersBuilder?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.pigeon_defaultConstructor", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_identifierArg = args[0] as Long
              val wrapped: List<Any?> = try {
                api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
                listOf(null)
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.pigeon_defaultConstructor",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.PeriodicAdvertisingParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.build", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.PeriodicAdvertisingParameters.Builder
              val wrapped: List<Any?> = try {
                listOf(api.build(pigeon_instanceArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.build",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.PeriodicAdvertisingParameters`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.setIncludeTxPower", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.PeriodicAdvertisingParameters.Builder
              val includeTxPowerArg = args[1] as Boolean
              val wrapped: List<Any?> = try {
                listOf(api.setIncludeTxPower(pigeon_instanceArg, includeTxPowerArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.setIncludeTxPower",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.PeriodicAdvertisingParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      if (android.os.Build.VERSION.SDK_INT >= 26) {
        run {
          val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.setInterval", codec)
          if (api != null) {
            channel.setMessageHandler { message, reply ->
              val args = message as List<Any?>
              val pigeon_instanceArg = args[0] as android.bluetooth.le.PeriodicAdvertisingParameters.Builder
              val intervalArg = args[1] as Long
              val wrapped: List<Any?> = try {
                listOf(api.setInterval(pigeon_instanceArg, intervalArg))
              } catch (exception: Throwable) {
                wrapError(exception)
              }
              reply.reply(wrapped)
            }
          } else {
            channel.setMessageHandler(null)
          }
        }
      }       else {
        val channel = BasicMessageChannel<Any?>(
          binaryMessenger,
          "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.setInterval",
          codec
        )
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            reply.reply(wrapError(UnsupportedOperationException(
              "Call references class `android.bluetooth.le.PeriodicAdvertisingParameters.Builder`, which requires api version 26."
            )))
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of PeriodicAdvertisingParametersBuilder and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 26)
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.PeriodicAdvertisingParameters.Builder, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.PeriodicAdvertisingParametersBuilder.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** Bluetooth LE scan callbacks. Scan results are reported using these callbacks. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiScanCallback(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.ScanCallback

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiScanCallback?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanCallback.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ScanCallback and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.ScanCallback, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      callback(
          Result.failure(
              BluetoothLowEnergyError("new-instance-error", "Attempting to create a new Dart instance of ScanCallback, but the class has a nonnull callback method.", "")))
    }
  }

  /** Callback when batch results are delivered. */
  fun onBatchScanResults(pigeon_instanceArg: android.bluetooth.le.ScanCallback, resultsArg: List<android.bluetooth.le.ScanResult>, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanCallback.onBatchScanResults"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, resultsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback when scan could not be started. */
  fun onScanFailed(pigeon_instanceArg: android.bluetooth.le.ScanCallback, errorCodeArg: Long, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanCallback.onScanFailed"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, errorCodeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  /** Callback when a BLE advertisement has been found. */
  fun onScanResult(pigeon_instanceArg: android.bluetooth.le.ScanCallback, resultArg: android.bluetooth.le.ScanResult, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
      return
    }
    val binaryMessenger = pigeonRegistrar.binaryMessenger
    val codec = pigeonRegistrar.codec
    val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanCallback.onScanResult"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(pigeon_instanceArg, resultArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Criteria for filtering result from Bluetooth LE scans. A ScanFilter allows
 * clients to restrict scan results to only those that are of interest to them.
 *
 * Current filtering on the following fields are supported:
 *
 * * Service UUIDs which identify the bluetooth gatt services running on the device.
 * * Name of remote Bluetooth LE device.
 * * Mac address of the remote device.
 * * Service data which is the data associated with a service.
 * * Manufacturer specific data which is the data associated with a particular manufacturer.
 * * Advertising data type and corresponding data.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiScanFilter(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Returns the advertising data of this filter. */
  abstract fun getAdvertisingData(pigeon_instance: android.bluetooth.le.ScanFilter): ByteArray?

  /** Returns the advertising data mask of this filter. */
  abstract fun getAdvertisingDataMask(pigeon_instance: android.bluetooth.le.ScanFilter): ByteArray?

  /**
   * Returns the advertising data type of this filter. Returns ScanRecord.DATA_TYPE_NONE
   * if the type is not set. The values of advertising data type are defined in
   * the Bluetooth Generic Access Profile (https://www.bluetooth.com/specifications/assigned-numbers/)
   */
  abstract fun getAdvertisingDataType(pigeon_instance: android.bluetooth.le.ScanFilter): Long

  abstract fun getDeviceAddress(pigeon_instance: android.bluetooth.le.ScanFilter): String?

  /**
   * Returns the filter set the device name field of Bluetooth advertisement
   * data.
   */
  abstract fun getDeviceName(pigeon_instance: android.bluetooth.le.ScanFilter): String?

  abstract fun getManufacturerData(pigeon_instance: android.bluetooth.le.ScanFilter): ByteArray?

  abstract fun getManufacturerDataMask(pigeon_instance: android.bluetooth.le.ScanFilter): ByteArray?

  /** Returns the manufacturer id. -1 if the manufacturer filter is not set. */
  abstract fun getManufacturerId(pigeon_instance: android.bluetooth.le.ScanFilter): Long

  abstract fun getServiceData(pigeon_instance: android.bluetooth.le.ScanFilter): ByteArray?

  abstract fun getServiceDataMask(pigeon_instance: android.bluetooth.le.ScanFilter): ByteArray?

  abstract fun getServiceDataUuid(pigeon_instance: android.bluetooth.le.ScanFilter): android.os.ParcelUuid?

  /** Returns the filter set on the service Solicitation uuid. */
  abstract fun getServiceSolicitationUuid(pigeon_instance: android.bluetooth.le.ScanFilter): android.os.ParcelUuid?

  /** Returns the filter set on the service Solicitation uuid mask. */
  abstract fun getServiceSolicitationUuidMask(pigeon_instance: android.bluetooth.le.ScanFilter): android.os.ParcelUuid?

  /** Returns the filter set on the service uuid. */
  abstract fun getServiceUuid(pigeon_instance: android.bluetooth.le.ScanFilter): android.os.ParcelUuid?

  abstract fun getServiceUuidMask(pigeon_instance: android.bluetooth.le.ScanFilter): android.os.ParcelUuid?

  /**
   * Check if the scan filter matches a scanResult. A scan result is considered
   * as a match if it matches all the field filters.
   */
  abstract fun matches(pigeon_instance: android.bluetooth.le.ScanFilter, scanResult: android.bluetooth.le.ScanResult): Boolean

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiScanFilter?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getAdvertisingData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getAdvertisingData(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getAdvertisingDataMask", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getAdvertisingDataMask(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getAdvertisingDataType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getAdvertisingDataType(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getDeviceAddress", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getDeviceAddress(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getDeviceName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getDeviceName(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getManufacturerData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getManufacturerData(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getManufacturerDataMask", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getManufacturerDataMask(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getManufacturerId", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getManufacturerId(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getServiceData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getServiceData(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getServiceDataMask", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getServiceDataMask(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getServiceDataUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getServiceDataUuid(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getServiceSolicitationUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getServiceSolicitationUuid(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getServiceSolicitationUuidMask", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getServiceSolicitationUuidMask(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getServiceUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getServiceUuid(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.getServiceUuidMask", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val wrapped: List<Any?> = try {
              listOf(api.getServiceUuidMask(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.matches", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter
            val scanResultArg = args[1] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.matches(pigeon_instanceArg, scanResultArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ScanFilter and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.ScanFilter, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilter.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** Builder class for ScanFilter. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiScanFilterBuilder(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.ScanFilter.Builder

  /** Build ScanFilter. */
  abstract fun build(pigeon_instance: android.bluetooth.le.ScanFilter.Builder): android.bluetooth.le.ScanFilter

  /**
   * Set filter on advertising data with specific advertising data type.
   *
   * The values of advertisingDataType are assigned by Bluetooth SIG. For more
   * details refer to Bluetooth Generic Access Profile.
   * (https://www.bluetooth.com/specifications/assigned-numbers/)
   */
  abstract fun setAdvertisingDataType(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, advertisingDataType: Long): android.bluetooth.le.ScanFilter.Builder

  /**
   * Set filter on advertising data with specific advertising data type. For any
   * bit in the mask, set it the 1 if it needs to match the one in advertising
   * data, otherwise set it to 0.
   *
   * The values of advertisingDataType are assigned by Bluetooth SIG. For more
   * details refer to Bluetooth Generic Access Profile.
   * (https://www.bluetooth.com/specifications/assigned-numbers/) The
   * advertisingDataMask must have the same length of advertisingData.
   */
  abstract fun setAdvertisingDataTypeWithData(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, advertisingDataType: Long, advertisingData: ByteArray, advertisingDataMask: ByteArray): android.bluetooth.le.ScanFilter.Builder

  /**
   * Set a scan filter on the remote device address.
   *
   * The address passed to this API must be in big endian byte order. It needs
   * to be in the format of "01:02:03:AB:CD:EF". The device address can be
   * validated using android.bluetooth.BluetoothAdapter#checkBluetoothAddress.
   * The @AddressType is defaulted to android.bluetooth.BluetoothDevice#ADDRESS_TYPE_PUBLIC.
   */
  abstract fun setDeviceAddress(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, deviceAddress: String): android.bluetooth.le.ScanFilter.Builder

  /** Set filter on device name. */
  abstract fun setDeviceName(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, deviceName: String): android.bluetooth.le.ScanFilter.Builder

  /**
   * Set filter on on manufacturerData. A negative manufacturerId is considered
   * as invalid id.
   */
  abstract fun setManufacturerData1(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, manufacturerId: Long, manufacturerData: ByteArray): android.bluetooth.le.ScanFilter.Builder

  /**
   * Set filter on partial manufacture data. For any bit in the mask, set it the
   * 1 if it needs to match the one in manufacturer data, otherwise set it to 0.
   *
   * The manufacturerDataMask must have the same length of manufacturerData.
   */
  abstract fun setManufacturerData2(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, manufacturerId: Long, manufacturerData: ByteArray, manufacturerDataMask: ByteArray): android.bluetooth.le.ScanFilter.Builder

  /** Set filtering on service data. */
  abstract fun setServiceData1(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, serviceDataUuid: android.os.ParcelUuid, serviceData: ByteArray): android.bluetooth.le.ScanFilter.Builder

  /**
   * Set partial filter on service data. For any bit in the mask, set it to 1 if
   * it needs to match the one in service data, otherwise set it to 0 to ignore
   * that bit.
   *
   * The serviceDataMask must have the same length of the serviceData.
   */
  abstract fun setServiceData2(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, serviceDataUuid: android.os.ParcelUuid, serviceData: ByteArray, serviceDataMask: ByteArray): android.bluetooth.le.ScanFilter.Builder

  /** Set filter on service solicitation uuid. */
  abstract fun setServiceSolicitationUuid1(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, serviceSolicitationUuid: android.os.ParcelUuid?): android.bluetooth.le.ScanFilter.Builder

  /**
   * Set filter on partial service Solicitation uuid. The SolicitationUuidMask
   * is the bit mask for the serviceSolicitationUuid. Set any bit in the mask to
   * 1 to indicate a match is needed for the bit in serviceSolicitationUuid, and
   * 0 to ignore that bit.
   */
  abstract fun setServiceSolicitationUuid2(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, serviceSolicitationUuid: android.os.ParcelUuid?, solicitationUuidMask: android.os.ParcelUuid?): android.bluetooth.le.ScanFilter.Builder

  /** Set filter on service uuid. */
  abstract fun setServiceUuid1(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, serviceUuid: android.os.ParcelUuid): android.bluetooth.le.ScanFilter.Builder

  /**
   * Set filter on partial service uuid. The uuidMask is the bit mask for the
   * serviceUuid. Set any bit in the mask to 1 to indicate a match is needed for
   * the bit in serviceUuid, and 0 to ignore that bit.
   */
  abstract fun setServiceUuid2(pigeon_instance: android.bluetooth.le.ScanFilter.Builder, serviceUuid: android.os.ParcelUuid, uuidMask: android.os.ParcelUuid): android.bluetooth.le.ScanFilter.Builder

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiScanFilterBuilder?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.build", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val wrapped: List<Any?> = try {
              listOf(api.build(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setAdvertisingDataType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val advertisingDataTypeArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setAdvertisingDataType(pigeon_instanceArg, advertisingDataTypeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setAdvertisingDataTypeWithData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val advertisingDataTypeArg = args[1] as Long
            val advertisingDataArg = args[2] as ByteArray
            val advertisingDataMaskArg = args[3] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.setAdvertisingDataTypeWithData(pigeon_instanceArg, advertisingDataTypeArg, advertisingDataArg, advertisingDataMaskArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setDeviceAddress", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val deviceAddressArg = args[1] as String
            val wrapped: List<Any?> = try {
              listOf(api.setDeviceAddress(pigeon_instanceArg, deviceAddressArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setDeviceName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val deviceNameArg = args[1] as String
            val wrapped: List<Any?> = try {
              listOf(api.setDeviceName(pigeon_instanceArg, deviceNameArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setManufacturerData1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val manufacturerIdArg = args[1] as Long
            val manufacturerDataArg = args[2] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.setManufacturerData1(pigeon_instanceArg, manufacturerIdArg, manufacturerDataArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setManufacturerData2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val manufacturerIdArg = args[1] as Long
            val manufacturerDataArg = args[2] as ByteArray
            val manufacturerDataMaskArg = args[3] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.setManufacturerData2(pigeon_instanceArg, manufacturerIdArg, manufacturerDataArg, manufacturerDataMaskArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setServiceData1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val serviceDataUuidArg = args[1] as android.os.ParcelUuid
            val serviceDataArg = args[2] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.setServiceData1(pigeon_instanceArg, serviceDataUuidArg, serviceDataArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setServiceData2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val serviceDataUuidArg = args[1] as android.os.ParcelUuid
            val serviceDataArg = args[2] as ByteArray
            val serviceDataMaskArg = args[3] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.setServiceData2(pigeon_instanceArg, serviceDataUuidArg, serviceDataArg, serviceDataMaskArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setServiceSolicitationUuid1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val serviceSolicitationUuidArg = args[1] as android.os.ParcelUuid?
            val wrapped: List<Any?> = try {
              listOf(api.setServiceSolicitationUuid1(pigeon_instanceArg, serviceSolicitationUuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setServiceSolicitationUuid2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val serviceSolicitationUuidArg = args[1] as android.os.ParcelUuid?
            val solicitationUuidMaskArg = args[2] as android.os.ParcelUuid?
            val wrapped: List<Any?> = try {
              listOf(api.setServiceSolicitationUuid2(pigeon_instanceArg, serviceSolicitationUuidArg, solicitationUuidMaskArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setServiceUuid1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val serviceUuidArg = args[1] as android.os.ParcelUuid
            val wrapped: List<Any?> = try {
              listOf(api.setServiceUuid1(pigeon_instanceArg, serviceUuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.setServiceUuid2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanFilter.Builder
            val serviceUuidArg = args[1] as android.os.ParcelUuid
            val uuidMaskArg = args[2] as android.os.ParcelUuid
            val wrapped: List<Any?> = try {
              listOf(api.setServiceUuid2(pigeon_instanceArg, serviceUuidArg, uuidMaskArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ScanFilterBuilder and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.ScanFilter.Builder, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanFilterBuilder.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** Represents a scan record from Bluetooth LE scan. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiScanRecord(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Returns the advertising flags indicating the discoverable mode and capability
   * of the device. Returns -1 if the flag field is not set.
   */
  abstract fun getAdvertiseFlags(pigeon_instance: android.bluetooth.le.ScanRecord): Long

  /**
   * Returns a map of advertising data type and its corresponding advertising
   * data. The values of advertising data type are defined in the Bluetooth
   * Generic Access Profile (https://www.bluetooth.com/specifications/assigned-numbers/)
   */
  abstract fun getAdvertisingDataMap(pigeon_instance: android.bluetooth.le.ScanRecord): Map<Long, ByteArray>

  /** Returns raw bytes of scan record. */
  abstract fun getBytes(pigeon_instance: android.bluetooth.le.ScanRecord): ByteArray

  /** Returns the local name of the BLE device. This is a UTF-8 encoded string. */
  abstract fun getDeviceName(pigeon_instance: android.bluetooth.le.ScanRecord): String?

  /**
   * Returns a sparse array of manufacturer identifier and its corresponding
   * manufacturer specific data.
   */
  abstract fun getManufacturerSpecificData1(pigeon_instance: android.bluetooth.le.ScanRecord): Map<Long, ByteArray>

  /**
   * Returns the manufacturer specific data associated with the manufacturer id.
   * Returns null if the manufacturerId is not found.
   */
  abstract fun getManufacturerSpecificData2(pigeon_instance: android.bluetooth.le.ScanRecord, manufacturerId: Long): ByteArray?

  /** Returns a map of service UUID and its corresponding service data. */
  abstract fun getServiceData1(pigeon_instance: android.bluetooth.le.ScanRecord): Map<android.os.ParcelUuid, ByteArray>

  /**
   * Returns the service data byte array associated with the serviceUuid. Returns
   * null if the serviceDataUuid is not found.
   */
  abstract fun getServiceData2(pigeon_instance: android.bluetooth.le.ScanRecord, serviceDataUuid: android.os.ParcelUuid): ByteArray?

  /**
   * Returns a list of service solicitation UUIDs within the advertisement that
   * are used to identify the Bluetooth GATT services.
   */
  abstract fun getServiceSolicitationUuids(pigeon_instance: android.bluetooth.le.ScanRecord): List<android.os.ParcelUuid>

  /**
   * Returns a list of service UUIDs within the advertisement that are used to
   * identify the bluetooth GATT services.
   */
  abstract fun getServiceUuids(pigeon_instance: android.bluetooth.le.ScanRecord): List<android.os.ParcelUuid>

  /**
   * Returns the transmission power level of the packet in dBm. Returns
   * Integer.MIN_VALUE if the field is not set. This value can be used to calculate
   * the path loss of a received packet using the following equation:
   *
   * `pathloss = txPowerLevel - rssi`
   */
  abstract fun getTxPowerLevel(pigeon_instance: android.bluetooth.le.ScanRecord): Long

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiScanRecord?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getAdvertiseFlags", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getAdvertiseFlags(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getAdvertisingDataMap", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getAdvertisingDataMap(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getBytes", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getBytes(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getDeviceName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getDeviceName(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getManufacturerSpecificData1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getManufacturerSpecificData1(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getManufacturerSpecificData2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val manufacturerIdArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.getManufacturerSpecificData2(pigeon_instanceArg, manufacturerIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getServiceData1", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getServiceData1(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getServiceData2", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val serviceDataUuidArg = args[1] as android.os.ParcelUuid
            val wrapped: List<Any?> = try {
              listOf(api.getServiceData2(pigeon_instanceArg, serviceDataUuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getServiceSolicitationUuids", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getServiceSolicitationUuids(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getServiceUuids", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getServiceUuids(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.getTxPowerLevel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanRecord
            val wrapped: List<Any?> = try {
              listOf(api.getTxPowerLevel(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ScanRecord and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.ScanRecord, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanRecord.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** ScanResult for Bluetooth LE scan. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiScanResult(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /**
   * Returns the advertising set id. May return ScanResult.SID_NOT_PRESENT if no
   * set id was is present.
   */
  abstract fun getAdvertisingSid(pigeon_instance: android.bluetooth.le.ScanResult): Long

  /**
   * Returns the data status. Can be one of ScanResult.DATA_COMPLETE or
   * android.bluetooth.le.ScanResult#DATA_TRUNCATED.
   */
  abstract fun getDataStatus(pigeon_instance: android.bluetooth.le.ScanResult): Long

  /**
   * Returns the remote Bluetooth device identified by the Bluetooth device
   * address. If the device is bonded, calling BluetoothDevice.getAddress on the
   * object returned by this method will return the address that was originally
   * bonded with (either identity address or random address).
   */
  abstract fun getDevice(pigeon_instance: android.bluetooth.le.ScanResult): android.bluetooth.BluetoothDevice

  /**
   * Returns the periodic advertising interval in units of 1.25ms. Valid range
   * is 6 (7.5ms) to 65536 (81918.75ms). A value of ScanResult.PERIODIC_INTERVAL_NOT_PRESENT
   * means periodic advertising interval is not present.
   */
  abstract fun getPeriodicAdvertisingInterval(pigeon_instance: android.bluetooth.le.ScanResult): Long

  /**
   * Returns the primary Physical Layer on which this advertisement was received.
   * Can be one of BluetoothDevice.PHY_LE_1M or BluetoothDevice.PHY_LE_CODED.
   */
  abstract fun getPrimaryPhy(pigeon_instance: android.bluetooth.le.ScanResult): Long

  /** Returns the received signal strength in dBm. The valid range is [-127, 126]. */
  abstract fun getRssi(pigeon_instance: android.bluetooth.le.ScanResult): Long

  /**
   * Returns the scan record, which is a combination of advertisement and scan
   * response.
   */
  abstract fun getScanRecord(pigeon_instance: android.bluetooth.le.ScanResult): android.bluetooth.le.ScanRecord?

  /**
   * Returns the secondary Physical Layer on which this advertisement was received.
   * Can be one of BluetoothDevice.PHY_LE_1M, BluetoothDevice.PHY_LE_2M,
   * android.bluetooth.BluetoothDevice#PHY_LE_CODED or ScanResult.PHY_UNUSED -
   * if the advertisement was not received on a secondary physical channel.
   */
  abstract fun getSecondaryPhy(pigeon_instance: android.bluetooth.le.ScanResult): Long

  /** Returns timestamp since boot when the scan record was observed. */
  abstract fun getTimestampNanos(pigeon_instance: android.bluetooth.le.ScanResult): Long

  /**
   * Returns the transmit power in dBm. Valid range is [-127, 126]. A value of
   * android.bluetooth.le.ScanResult#TX_POWER_NOT_PRESENT indicates that the TX
   * power is not present.
   */
  abstract fun getTxPower(pigeon_instance: android.bluetooth.le.ScanResult): Long

  /** Returns true if this object represents connectable scan result. */
  abstract fun isConnectable(pigeon_instance: android.bluetooth.le.ScanResult): Boolean

  /**
   * Returns true if this object represents legacy scan result. Legacy scan
   * results do not contain advanced advertising information as specified in the
   * Bluetooth Core Specification v5.
   */
  abstract fun isLegacy(pigeon_instance: android.bluetooth.le.ScanResult): Boolean

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiScanResult?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getAdvertisingSid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getAdvertisingSid(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getDataStatus", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getDataStatus(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getDevice", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getDevice(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getPeriodicAdvertisingInterval", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getPeriodicAdvertisingInterval(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getPrimaryPhy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getPrimaryPhy(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getRssi", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getRssi(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getScanRecord", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getScanRecord(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getSecondaryPhy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getSecondaryPhy(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getTimestampNanos", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getTimestampNanos(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.getTxPower", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.getTxPower(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.isConnectable", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.isConnectable(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.isLegacy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanResult
            val wrapped: List<Any?> = try {
              listOf(api.isLegacy(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ScanResult and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.ScanResult, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanResult.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Bluetooth LE scan settings are passed to android.bluetooth.le.BluetoothLeScanner#startScan
 * to define the parameters for the scan.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiScanSettings(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun getCallbackType(pigeon_instance: android.bluetooth.le.ScanSettings): Long

  /**
   * Returns whether only legacy advertisements will be returned. Legacy
   * advertisements include advertisements as specified by the Bluetooth core
   * specification 4.2 and below.
   */
  abstract fun getLegacy(pigeon_instance: android.bluetooth.le.ScanSettings): Boolean

  /** Returns the physical layer used during a scan. */
  abstract fun getPhy(pigeon_instance: android.bluetooth.le.ScanSettings): Long

  /** Returns report delay timestamp based on the device clock. */
  abstract fun getReportDelayMillis(pigeon_instance: android.bluetooth.le.ScanSettings): Long

  abstract fun getScanMode(pigeon_instance: android.bluetooth.le.ScanSettings): Long

  abstract fun getScanResultType(pigeon_instance: android.bluetooth.le.ScanSettings): Long

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiScanSettings?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettings.getCallbackType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings
            val wrapped: List<Any?> = try {
              listOf(api.getCallbackType(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettings.getLegacy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings
            val wrapped: List<Any?> = try {
              listOf(api.getLegacy(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettings.getPhy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings
            val wrapped: List<Any?> = try {
              listOf(api.getPhy(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettings.getReportDelayMillis", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings
            val wrapped: List<Any?> = try {
              listOf(api.getReportDelayMillis(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettings.getScanMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings
            val wrapped: List<Any?> = try {
              listOf(api.getScanMode(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettings.getScanResultType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings
            val wrapped: List<Any?> = try {
              listOf(api.getScanResultType(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ScanSettings and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.ScanSettings, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettings.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/** Builder for ScanSettings. */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiScanSettingsBuilder(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(): android.bluetooth.le.ScanSettings.Builder

  /** Build ScanSettings. */
  abstract fun build(pigeon_instance: android.bluetooth.le.ScanSettings.Builder): android.bluetooth.le.ScanSettings

  /** Set callback type for Bluetooth LE scan. */
  abstract fun setCallbackType(pigeon_instance: android.bluetooth.le.ScanSettings.Builder, callbackType: Long): android.bluetooth.le.ScanSettings.Builder

  /**
   * Set whether only legacy advertisements should be returned in scan results.
   * Legacy advertisements include advertisements as specified by the Bluetooth
   * core specification 4.2 and below. This is true by default for compatibility
   * with older apps.
   */
  abstract fun setLegacy(pigeon_instance: android.bluetooth.le.ScanSettings.Builder, legacy: Boolean): android.bluetooth.le.ScanSettings.Builder

  /** Set match mode for Bluetooth LE scan filters hardware match. */
  abstract fun setMatchMode(pigeon_instance: android.bluetooth.le.ScanSettings.Builder, matchMode: Long): android.bluetooth.le.ScanSettings.Builder

  /** Set the number of matches for Bluetooth LE scan filters hardware match. */
  abstract fun setNumOfMatches(pigeon_instance: android.bluetooth.le.ScanSettings.Builder, numOfMatches: Long): android.bluetooth.le.ScanSettings.Builder

  /**
   * Set the Physical Layer to use during this scan. This is used only if
   * android.bluetooth.le.ScanSettings.Builder#setLegacy is set to false.
   * android.bluetooth.BluetoothAdapter#isLeCodedPhySupported may be used to
   * check whether LE Coded phy is supported by calling
   * android.bluetooth.BluetoothAdapter#isLeCodedPhySupported. Selecting an
   * unsupported phy will result in failure to start scan.
   */
  abstract fun setPhy(pigeon_instance: android.bluetooth.le.ScanSettings.Builder, phy: Long): android.bluetooth.le.ScanSettings.Builder

  /**
   * Set report delay timestamp for Bluetooth LE scan. If set to 0, you will be
   * notified of scan results immediately. If > 0, scan results are queued up
   * and delivered after the requested delay or 5000 milliseconds (whichever is
   * higher). Note scan results may be delivered sooner if the internal buffers
   * fill up.
   */
  abstract fun setReportDelay(pigeon_instance: android.bluetooth.le.ScanSettings.Builder, reportDelayMillis: Long): android.bluetooth.le.ScanSettings.Builder

  /** Set scan mode for Bluetooth LE scan. */
  abstract fun setScanMode(pigeon_instance: android.bluetooth.le.ScanSettings.Builder, scanMode: Long): android.bluetooth.le.ScanSettings.Builder

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiScanSettingsBuilder?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.build", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings.Builder
            val wrapped: List<Any?> = try {
              listOf(api.build(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.setCallbackType", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings.Builder
            val callbackTypeArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setCallbackType(pigeon_instanceArg, callbackTypeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.setLegacy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings.Builder
            val legacyArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.setLegacy(pigeon_instanceArg, legacyArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.setMatchMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings.Builder
            val matchModeArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setMatchMode(pigeon_instanceArg, matchModeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.setNumOfMatches", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings.Builder
            val numOfMatchesArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setNumOfMatches(pigeon_instanceArg, numOfMatchesArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.setPhy", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings.Builder
            val phyArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setPhy(pigeon_instanceArg, phyArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.setReportDelay", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings.Builder
            val reportDelayMillisArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setReportDelay(pigeon_instanceArg, reportDelayMillisArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.setScanMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.bluetooth.le.ScanSettings.Builder
            val scanModeArg = args[1] as Long
            val wrapped: List<Any?> = try {
              listOf(api.setScanMode(pigeon_instanceArg, scanModeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ScanSettingsBuilder and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.ScanSettings.Builder, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ScanSettingsBuilder.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Wrapper for Transport Discovery Data Transport Blocks. This class represents
 * a Transport Block from a Transport Discovery Data.
 */
@Suppress("UNCHECKED_CAST")
open class PigeonApiTransportBlock(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of TransportBlock and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 33)
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.TransportBlock, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.TransportBlock.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Wrapper for Transport Discovery Data AD Type. This class contains the Transport
 * Discovery Data AD Type Code as well as a list of potential Transport Blocks.
 */
@Suppress("UNCHECKED_CAST")
open class PigeonApiTransportDiscoveryData(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of TransportDiscoveryData and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 33)
  fun pigeon_newInstance(pigeon_instanceArg: android.bluetooth.le.TransportDiscoveryData, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.TransportDiscoveryData.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Interface to global information about an application environment. This is an
 * abstract class whose implementation is provided by the Android system. It
 * allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.
 */
@Suppress("UNCHECKED_CAST")
open class PigeonApiContext(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of Context and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.content.Context, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.Context.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
@Suppress("UNCHECKED_CAST")
open class PigeonApiIntent(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of Intent and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.content.Intent, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.Intent.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * A Handler allows you to send and process Message and Runnable objects associated
 * with a thread's MessageQueue. Each Handler instance is associated with a single
 * thread and that thread's message queue. When you create a new Handler it is
 * bound to a Looper. It will deliver messages and runnables to that Looper's
 * message queue and execute them on that Looper's thread.
 *
 * There are two main uses for a Handler: (1) to schedule messages and runnables
 * to be executed at some point in the future; and (2) to enqueue an action to
 * be performed on a different thread than your own.
 *
 * Scheduling messages is accomplished with the post, postAtTime(java.lang.Runnable,long),
 * #postDelayed, sendEmptyMessage, sendMessage, sendMessageAtTime, and
 * sendMessageDelayed methods. The post versions allow you to enqueue Runnable
 * objects to be called by the message queue when they are received; the sendMessage
 * versions allow you to enqueue a Message object containing a bundle of data
 * that will be processed by the Handler's handleMessage method (requiring that
 * you implement a subclass of Handler).
 *
 * When posting or sending to a Handler, you can either allow the item to be
 * processed as soon as the message queue is ready to do so, or specify a delay
 * before it gets processed or absolute time for it to be processed. The latter
 * two allow you to implement timeouts, ticks, and other timing-based behavior.
 *
 * When a process is created for your application, its main thread is dedicated
 * to running a message queue that takes care of managing the top-level application
 * objects (activities, broadcast receivers, etc) and any windows they create.
 * You can create your own threads, and communicate back with the main application
 * thread through a Handler. This is done by calling the same post or sendMessage
 * methods as before, but from your new thread. The given Runnable or Message
 * will then be scheduled in the Handler's message queue and processed when
 * appropriate.
 */
@Suppress("UNCHECKED_CAST")
open class PigeonApiHandler(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of Handler and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.os.Handler, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.Handler.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * This class is a Parcelable wrapper around UUID which is an immutable representation
 * of a 128-bit universally unique identifier.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiParcelUuid(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  /** Constructor creates a ParcelUuid instance from the given UUID. */
  abstract fun pigeon_defaultConstructor(uuid: java.util.UUID): android.os.ParcelUuid

  /** Creates a new ParcelUuid from a string representation of UUID. */
  abstract fun fromString(uuid: String): android.os.ParcelUuid

  /** Get the UUID represented by the ParcelUuid. */
  abstract fun getUuid(pigeon_instance: android.os.ParcelUuid): java.util.UUID

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiParcelUuid?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ParcelUuid.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val uuidArg = args[1] as java.util.UUID
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(uuidArg), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ParcelUuid.fromString", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.fromString(uuidArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.ParcelUuid.getUuid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as android.os.ParcelUuid
            val wrapped: List<Any?> = try {
              listOf(api.getUuid(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of ParcelUuid and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: android.os.ParcelUuid, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.ParcelUuid.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * This abstract class is the superclass of all classes representing an input
 * stream of bytes.
 *
 * Applications that need to define a subclass of InputStream must always provide
 * a method that returns the next byte of input.
 */
@Suppress("UNCHECKED_CAST")
open class PigeonApiInputStream(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of InputStream and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: java.io.InputStream, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.InputStream.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * This abstract class is the superclass of all classes representing an output
 * stream of bytes. An output stream accepts output bytes and sends them to some
 * sink.
 *
 * Applications that need to define a subclass of OutputStream must always provide
 * at least a method that writes one byte of output.
 */
@Suppress("UNCHECKED_CAST")
open class PigeonApiOutputStream(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of OutputStream and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: java.io.OutputStream, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.OutputStream.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * A time-based amount of time, such as '34.5 seconds'.
 *
 * This class models a quantity or amount of time in terms of seconds and
 * nanoseconds. It can be accessed using other duration-based units, such as
 * minutes and hours. In addition, the DAYS unit can be used and is treated as
 * exactly equal to 24 hours, thus ignoring daylight savings effects. See Period
 * for the date-based equivalent to this class.
 *
 * A physical duration could be of infinite length. For practicality, the duration
 * is stored with constraints similar to Instant. The duration uses nanosecond
 * resolution with a maximum value of the seconds that can be held in a long.
 * This is greater than the current estimated age of the universe.
 *
 * The range of a duration requires the storage of a number larger than a long.
 * To achieve this, the class stores a long representing seconds and an int
 * representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 * The model is of a directed duration, meaning that the duration may be negative.
 *
 * The duration is measured in "seconds", but these are not necessarily identical
 * to the scientific "SI second" definition based on atomic clocks. This difference
 * only impacts durations measured near a leap-second and should not affect most
 * applications. See Instant for a discussion as to the meaning of the second
 * and time-scales.
 */
@Suppress("UNCHECKED_CAST")
open class PigeonApiDuration(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of Duration and attaches it to [pigeon_instanceArg]. */
  @androidx.annotation.RequiresApi(api = 26)
  fun pigeon_newInstance(pigeon_instanceArg: java.time.Duration, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.Duration.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
/**
 * Constructs a new UUID using the specified data. mostSigBits is used for the
 * most significant 64 bits of the UUID and leastSigBits becomes the least
 * significant 64 bits of the UUID.
 */
@Suppress("UNCHECKED_CAST")
abstract class PigeonApiUUID(open val pigeonRegistrar: BluetoothLowEnergyPigeonProxyApiRegistrar) {
  abstract fun pigeon_defaultConstructor(mostSigBits: Long, leastSigBits: Long): java.util.UUID

  /**
   * The clock sequence value associated with this UUID.
   *
   * The 14 bit clock sequence value is constructed from the clock sequence field
   * of this UUID. The clock sequence field is used to guarantee temporal uniqueness
   * in a time-based UUID.
   *
   * The clockSequence value is only meaningful in a time-based UUID, which has
   * version type 1. If this UUID is not a time-based UUID then this method throws
   * UnsupportedOperationException.
   */
  abstract fun clockSequence(pigeon_instance: java.util.UUID): Long

  /**
   * Compares this UUID with the specified UUID.
   *
   * The first of two UUIDs is greater than the second if the most significant
   * field in which the UUIDs differ is greater for the first UUID.
   */
  abstract fun compareTo(pigeon_instance: java.util.UUID, other: java.util.UUID): Long

  /**
   * Creates a UUID from the string standard representation as described in the
   * toString method.
   */
  abstract fun fromString(name: String): java.util.UUID

  /** Returns the least significant 64 bits of this UUID's 128 bit value. */
  abstract fun getLeastSignificantBits(pigeon_instance: java.util.UUID): Long

  /** Returns the most significant 64 bits of this UUID's 128 bit value. */
  abstract fun getMostSignificantBits(pigeon_instance: java.util.UUID): Long

  /**
   * Static factory to retrieve a type 3 (name based) UUID based on the specified
   * byte array.
   */
  abstract fun nameUUIDFromBytes(name: ByteArray): java.util.UUID

  /**
   * The node value associated with this UUID.
   *
   * The 48 bit node value is constructed from the node field of this UUID. This
   * field is intended to hold the IEEE 802 address of the machine that generated
   * this UUID to guarantee spatial uniqueness.
   *
   * The node value is only meaningful in a time-based UUID, which has version
   * type 1. If this UUID is not a time-based UUID then this method throws
   * UnsupportedOperationException.
   */
  abstract fun node(pigeon_instance: java.util.UUID): Long

  /**
   * Static factory to retrieve a type 4 (pseudo randomly generated) UUID. The
   * UUID is generated using a cryptographically strong pseudo random number
   * generator.
   */
  abstract fun randomUUID(): java.util.UUID

  /**
   * The timestamp value associated with this UUID.
   *
   * The 60 bit timestamp value is constructed from the time_low, time_mid, and
   * time_hi fields of this UUID. The resulting timestamp is measured in
   * 100-nanosecond units since midnight, October 15, 1582 UTC.
   *
   * The timestamp value is only meaningful in a time-based UUID, which has
   * version type 1. If this UUID is not a time-based UUID then this method throws
   * UnsupportedOperationException.
   */
  abstract fun timestamp(pigeon_instance: java.util.UUID): Long

  /**
   * The variant number associated with this UUID. The variant number describes the layout of the UUID. The variant number has the following meaning:
   *
   * * 0 Reserved for NCS backward compatibility
   * * 2 IETF RFC 4122 (Leach-Salz), used by this class
   * * 6 Reserved, Microsoft Corporation backward compatibility
   * * 7 Reserved for future definition
   */
  abstract fun variant(pigeon_instance: java.util.UUID): Long

  companion object {
    @Suppress("LocalVariableName")
    fun setUpMessageHandlers(binaryMessenger: BinaryMessenger, api: PigeonApiUUID?) {
      val codec = api?.pigeonRegistrar?.codec ?: BluetoothLowEnergyPigeonCodec()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.pigeon_defaultConstructor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_identifierArg = args[0] as Long
            val mostSigBitsArg = args[1] as Long
            val leastSigBitsArg = args[2] as Long
            val wrapped: List<Any?> = try {
              api.pigeonRegistrar.instanceManager.addDartCreatedInstance(api.pigeon_defaultConstructor(mostSigBitsArg,leastSigBitsArg), pigeon_identifierArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.clockSequence", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.clockSequence(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.compareTo", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as java.util.UUID
            val otherArg = args[1] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.compareTo(pigeon_instanceArg, otherArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.fromString", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val nameArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.fromString(nameArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.getLeastSignificantBits", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.getLeastSignificantBits(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.getMostSignificantBits", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.getMostSignificantBits(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.nameUUIDFromBytes", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val nameArg = args[0] as ByteArray
            val wrapped: List<Any?> = try {
              listOf(api.nameUUIDFromBytes(nameArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.node", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.node(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.randomUUID", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.randomUUID())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.timestamp", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.timestamp(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.variant", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pigeon_instanceArg = args[0] as java.util.UUID
            val wrapped: List<Any?> = try {
              listOf(api.variant(pigeon_instanceArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }

  @Suppress("LocalVariableName", "FunctionName")
  /** Creates a Dart instance of UUID and attaches it to [pigeon_instanceArg]. */
  fun pigeon_newInstance(pigeon_instanceArg: java.util.UUID, callback: (Result<Unit>) -> Unit)
{
    if (pigeonRegistrar.ignoreCallsToDart) {
      callback(
          Result.failure(
              BluetoothLowEnergyError("ignore-calls-error", "Calls to Dart are being ignored.", "")))
    }     else if (pigeonRegistrar.instanceManager.containsInstance(pigeon_instanceArg)) {
      callback(Result.success(Unit))
    }     else {
      val pigeon_identifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeon_instanceArg)
      val binaryMessenger = pigeonRegistrar.binaryMessenger
      val codec = pigeonRegistrar.codec
      val channelName = "dev.flutter.pigeon.bluetooth_low_energy_android.UUID.pigeon_newInstance"
      val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
      channel.send(listOf(pigeon_identifierArg)) {
        if (it is List<*>) {
          if (it.size > 1) {
            callback(Result.failure(BluetoothLowEnergyError(it[0] as String, it[1] as String, it[2] as String?)))
          } else {
            callback(Result.success(Unit))
          }
        } else {
          callback(Result.failure(createConnectionError(channelName)))
        } 
      }
    }
  }

  @Suppress("FunctionName")
  /** An implementation of [PigeonApiAny] used to access callback methods */
  fun pigeon_getPigeonApiAny(): PigeonApiAny
  {
    return pigeonRegistrar.getPigeonApiAny()
  }

}
