// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bluetoothAvailable // = 0
  case bluetoothState // = 1
  case centralStartDiscovery // = 2
  case centralStopDiscovery // = 3
  case centralDiscovered // = 4
  case centralConnect // = 5
  case gattDisconnect // = 6
  case gattConnectionLost // = 7
  case gattCharacteristicRead // = 8
  case gattCharacteristicWrite // = 9
  case gattCharacteristicNotify // = 10
  case gattDescriptorRead // = 11
  case gattDescriptorWrite // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .bluetoothAvailable
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bluetoothAvailable
    case 1: self = .bluetoothState
    case 2: self = .centralStartDiscovery
    case 3: self = .centralStopDiscovery
    case 4: self = .centralDiscovered
    case 5: self = .centralConnect
    case 6: self = .gattDisconnect
    case 7: self = .gattConnectionLost
    case 8: self = .gattCharacteristicRead
    case 9: self = .gattCharacteristicWrite
    case 10: self = .gattCharacteristicNotify
    case 11: self = .gattDescriptorRead
    case 12: self = .gattDescriptorWrite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bluetoothAvailable: return 0
    case .bluetoothState: return 1
    case .centralStartDiscovery: return 2
    case .centralStopDiscovery: return 3
    case .centralDiscovered: return 4
    case .centralConnect: return 5
    case .gattDisconnect: return 6
    case .gattConnectionLost: return 7
    case .gattCharacteristicRead: return 8
    case .gattCharacteristicWrite: return 9
    case .gattCharacteristicNotify: return 10
    case .gattDescriptorRead: return 11
    case .gattDescriptorWrite: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory] = [
    .bluetoothAvailable,
    .bluetoothState,
    .centralStartDiscovery,
    .centralStopDiscovery,
    .centralDiscovered,
    .centralConnect,
    .gattDisconnect,
    .gattConnectionLost,
    .gattCharacteristicRead,
    .gattCharacteristicWrite,
    .gattCharacteristicNotify,
    .gattDescriptorRead,
    .gattDescriptorWrite,
  ]
}

#endif  // swift(>=4.2)

struct Dev_Yanshouwang_BluetoothLowEnergy_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var category: Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory = .bluetoothAvailable

  var value: Dev_Yanshouwang_BluetoothLowEnergy_Message.OneOf_Value? = nil

  var state: Bool {
    get {
      if case .state(let v)? = value {return v}
      return false
    }
    set {value = .state(newValue)}
  }

  var discovery: Dev_Yanshouwang_BluetoothLowEnergy_Discovery {
    get {
      if case .discovery(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_Discovery()
    }
    set {value = .discovery(newValue)}
  }

  var scanning: Bool {
    get {
      if case .scanning(let v)? = value {return v}
      return false
    }
    set {value = .scanning(newValue)}
  }

  var connectionLost: Dev_Yanshouwang_BluetoothLowEnergy_ConnectionLost {
    get {
      if case .connectionLost(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_ConnectionLost()
    }
    set {value = .connectionLost(newValue)}
  }

  var characteristicValue: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue {
    get {
      if case .characteristicValue(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue()
    }
    set {value = .characteristicValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case state(Bool)
    case discovery(Dev_Yanshouwang_BluetoothLowEnergy_Discovery)
    case scanning(Bool)
    case connectionLost(Dev_Yanshouwang_BluetoothLowEnergy_ConnectionLost)
    case characteristicValue(Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue)

  #if !swift(>=4.1)
    static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_Message.OneOf_Value, rhs: Dev_Yanshouwang_BluetoothLowEnergy_Message.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.state, .state): return {
        guard case .state(let l) = lhs, case .state(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discovery, .discovery): return {
        guard case .discovery(let l) = lhs, case .discovery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scanning, .scanning): return {
        guard case .scanning(let l) = lhs, case .scanning(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectionLost, .connectionLost): return {
        guard case .connectionLost(let l) = lhs, case .connectionLost(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.characteristicValue, .characteristicValue): return {
        guard case .characteristicValue(let l) = lhs, case .characteristicValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var services: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_Discovery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var rssi: Int32 = 0

  var advertisements: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GATT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var mtu: Int32 = 0

  var services: [Dev_Yanshouwang_BluetoothLowEnergy_GattService] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var id: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var uuid: String = String()

  var characteristics: [Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var uuid: String = String()

  var descriptors: [Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor] = []

  var canRead: Bool = false

  var canWrite: Bool = false

  var canWriteWithoutResponse: Bool = false

  var canNotify: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_ConnectionLost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var errorCode: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var serviceUuid: String = String()

  var uuid: String = String()

  var id: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var serviceUuid: String = String()

  var uuid: String = String()

  var id: Int32 = 0

  var value: Data = Data()

  var withoutResponse: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var serviceUuid: String = String()

  var uuid: String = String()

  var id: Int32 = 0

  var state: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var serviceUuid: String = String()

  var characteristicUuid: String = String()

  var uuid: String = String()

  var id: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var serviceUuid: String = String()

  var characteristicUuid: String = String()

  var uuid: String = String()

  var id: Int32 = 0

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "dev.yanshouwang.bluetooth_low_energy"

extension Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLUETOOTH_AVAILABLE"),
    1: .same(proto: "BLUETOOTH_STATE"),
    2: .same(proto: "CENTRAL_START_DISCOVERY"),
    3: .same(proto: "CENTRAL_STOP_DISCOVERY"),
    4: .same(proto: "CENTRAL_DISCOVERED"),
    5: .same(proto: "CENTRAL_CONNECT"),
    6: .same(proto: "GATT_DISCONNECT"),
    7: .same(proto: "GATT_CONNECTION_LOST"),
    8: .same(proto: "GATT_CHARACTERISTIC_READ"),
    9: .same(proto: "GATT_CHARACTERISTIC_WRITE"),
    10: .same(proto: "GATT_CHARACTERISTIC_NOTIFY"),
    11: .same(proto: "GATT_DESCRIPTOR_READ"),
    12: .same(proto: "GATT_DESCRIPTOR_WRITE"),
  ]
}

extension Dev_Yanshouwang_BluetoothLowEnergy_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "state"),
    3: .same(proto: "discovery"),
    4: .same(proto: "scanning"),
    5: .same(proto: "connectionLost"),
    6: .same(proto: "characteristicValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .state(v)
        }
      }()
      case 3: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_Discovery?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .discovery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .discovery(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .scanning(v)
        }
      }()
      case 5: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_ConnectionLost?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .connectionLost(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .connectionLost(v)
        }
      }()
      case 6: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .characteristicValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .characteristicValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .bluetoothAvailable {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .state?: try {
      guard case .state(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .discovery?: try {
      guard case .discovery(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .scanning?: try {
      guard case .scanning(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .connectionLost?: try {
      guard case .connectionLost(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .characteristicValue?: try {
      guard case .characteristicValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_Message, rhs: Dev_Yanshouwang_BluetoothLowEnergy_Message) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartDiscoveryArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.services.isEmpty {
      try visitor.visitRepeatedStringField(value: self.services, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_Discovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Discovery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "rssi"),
    3: .same(proto: "advertisements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.rssi) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.advertisements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.rssi != 0 {
      try visitor.visitSingularSInt32Field(value: self.rssi, fieldNumber: 2)
    }
    if !self.advertisements.isEmpty {
      try visitor.visitSingularBytesField(value: self.advertisements, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_Discovery, rhs: Dev_Yanshouwang_BluetoothLowEnergy_Discovery) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.advertisements != rhs.advertisements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GATT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GATT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "mtu"),
    3: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.mtu) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.mtu != 0 {
      try visitor.visitSingularInt32Field(value: self.mtu, fieldNumber: 2)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GATT, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GATT) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.mtu != rhs.mtu {return false}
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattDisconnectArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattService"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uuid"),
    3: .same(proto: "characteristics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattService, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattService) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uuid"),
    3: .same(proto: "descriptors"),
    4: .same(proto: "canRead"),
    5: .same(proto: "canWrite"),
    6: .same(proto: "canWriteWithoutResponse"),
    7: .same(proto: "canNotify"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.descriptors) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.canRead) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.canWrite) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.canWriteWithoutResponse) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.canNotify) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    if !self.descriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptors, fieldNumber: 3)
    }
    if self.canRead != false {
      try visitor.visitSingularBoolField(value: self.canRead, fieldNumber: 4)
    }
    if self.canWrite != false {
      try visitor.visitSingularBoolField(value: self.canWrite, fieldNumber: 5)
    }
    if self.canWriteWithoutResponse != false {
      try visitor.visitSingularBoolField(value: self.canWriteWithoutResponse, fieldNumber: 6)
    }
    if self.canNotify != false {
      try visitor.visitSingularBoolField(value: self.canNotify, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.descriptors != rhs.descriptors {return false}
    if lhs.canRead != rhs.canRead {return false}
    if lhs.canWrite != rhs.canWrite {return false}
    if lhs.canWriteWithoutResponse != rhs.canWriteWithoutResponse {return false}
    if lhs.canNotify != rhs.canNotify {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_ConnectionLost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionLost"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "error_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.errorCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.errorCode != 0 {
      try visitor.visitSingularInt32Field(value: self.errorCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_ConnectionLost, rhs: Dev_Yanshouwang_BluetoothLowEnergy_ConnectionLost) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristicReadArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "service_uuid"),
    3: .same(proto: "uuid"),
    4: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 3)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristicWriteArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "service_uuid"),
    3: .same(proto: "uuid"),
    4: .same(proto: "id"),
    5: .same(proto: "value"),
    6: .same(proto: "withoutResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.withoutResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 3)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 5)
    }
    if self.withoutResponse != false {
      try visitor.visitSingularBoolField(value: self.withoutResponse, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.value != rhs.value {return false}
    if lhs.withoutResponse != rhs.withoutResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristicNotifyArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "service_uuid"),
    3: .same(proto: "uuid"),
    4: .same(proto: "id"),
    5: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 3)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 4)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristicValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "id"),
    4: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattDescriptorReadArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "service_uuid"),
    3: .standard(proto: "characteristic_uuid"),
    4: .same(proto: "uuid"),
    5: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.characteristicUuid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.characteristicUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.characteristicUuid, fieldNumber: 3)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.characteristicUuid != rhs.characteristicUuid {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattDescriptorWriteArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "service_uuid"),
    3: .standard(proto: "characteristic_uuid"),
    4: .same(proto: "uuid"),
    5: .same(proto: "id"),
    6: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.characteristicUuid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.characteristicUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.characteristicUuid, fieldNumber: 3)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 5)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.characteristicUuid != rhs.characteristicUuid {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
