// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bluetoothState // = 0
  case centralStartDiscovery // = 1
  case centralStopDiscovery // = 2
  case centralDiscovered // = 3
  case centralConnect // = 4
  case gattDisconnect // = 5
  case gattConnectionLost // = 6
  case gattCharacteristicRead // = 7
  case gattCharacteristicWrite // = 8
  case gattCharacteristicNotify // = 9
  case gattDescriptorRead // = 10
  case gattDescriptorWrite // = 11
  case UNRECOGNIZED(Int)

  init() {
    self = .bluetoothState
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bluetoothState
    case 1: self = .centralStartDiscovery
    case 2: self = .centralStopDiscovery
    case 3: self = .centralDiscovered
    case 4: self = .centralConnect
    case 5: self = .gattDisconnect
    case 6: self = .gattConnectionLost
    case 7: self = .gattCharacteristicRead
    case 8: self = .gattCharacteristicWrite
    case 9: self = .gattCharacteristicNotify
    case 10: self = .gattDescriptorRead
    case 11: self = .gattDescriptorWrite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bluetoothState: return 0
    case .centralStartDiscovery: return 1
    case .centralStopDiscovery: return 2
    case .centralDiscovered: return 3
    case .centralConnect: return 4
    case .gattDisconnect: return 5
    case .gattConnectionLost: return 6
    case .gattCharacteristicRead: return 7
    case .gattCharacteristicWrite: return 8
    case .gattCharacteristicNotify: return 9
    case .gattDescriptorRead: return 10
    case .gattDescriptorWrite: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory] = [
    .bluetoothState,
    .centralStartDiscovery,
    .centralStopDiscovery,
    .centralDiscovered,
    .centralConnect,
    .gattDisconnect,
    .gattConnectionLost,
    .gattCharacteristicRead,
    .gattCharacteristicWrite,
    .gattCharacteristicNotify,
    .gattDescriptorRead,
    .gattDescriptorWrite,
  ]
}

#endif  // swift(>=4.2)

enum Dev_Yanshouwang_BluetoothLowEnergy_BluetoothState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unsupported // = 0
  case poweredOff // = 1
  case poweredOn // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unsupported
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unsupported
    case 1: self = .poweredOff
    case 2: self = .poweredOn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unsupported: return 0
    case .poweredOff: return 1
    case .poweredOn: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dev_Yanshouwang_BluetoothLowEnergy_BluetoothState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Dev_Yanshouwang_BluetoothLowEnergy_BluetoothState] = [
    .unsupported,
    .poweredOff,
    .poweredOn,
  ]
}

#endif  // swift(>=4.2)

struct Dev_Yanshouwang_BluetoothLowEnergy_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var category: Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory = .bluetoothState

  var value: Dev_Yanshouwang_BluetoothLowEnergy_Message.OneOf_Value? = nil

  var state: Dev_Yanshouwang_BluetoothLowEnergy_BluetoothState {
    get {
      if case .state(let v)? = value {return v}
      return .unsupported
    }
    set {value = .state(newValue)}
  }

  var startDiscoveryArguments: Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments {
    get {
      if case .startDiscoveryArguments(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments()
    }
    set {value = .startDiscoveryArguments(newValue)}
  }

  var discovery: Dev_Yanshouwang_BluetoothLowEnergy_Discovery {
    get {
      if case .discovery(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_Discovery()
    }
    set {value = .discovery(newValue)}
  }

  var connectArguments: Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments {
    get {
      if case .connectArguments(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments()
    }
    set {value = .connectArguments(newValue)}
  }

  var disconnectArguments: Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments {
    get {
      if case .disconnectArguments(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments()
    }
    set {value = .disconnectArguments(newValue)}
  }

  var connectionLost: Dev_Yanshouwang_BluetoothLowEnergy_GattConnectionLost {
    get {
      if case .connectionLost(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattConnectionLost()
    }
    set {value = .connectionLost(newValue)}
  }

  var characteristicReadArguments: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments {
    get {
      if case .characteristicReadArguments(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments()
    }
    set {value = .characteristicReadArguments(newValue)}
  }

  var characteristicWriteArguments: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments {
    get {
      if case .characteristicWriteArguments(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments()
    }
    set {value = .characteristicWriteArguments(newValue)}
  }

  var characteristicNotifyArguments: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments {
    get {
      if case .characteristicNotifyArguments(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments()
    }
    set {value = .characteristicNotifyArguments(newValue)}
  }

  var characteristicValue: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue {
    get {
      if case .characteristicValue(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue()
    }
    set {value = .characteristicValue(newValue)}
  }

  var descriptorReadArguments: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments {
    get {
      if case .descriptorReadArguments(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments()
    }
    set {value = .descriptorReadArguments(newValue)}
  }

  var descriptorWriteArguments: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments {
    get {
      if case .descriptorWriteArguments(let v)? = value {return v}
      return Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments()
    }
    set {value = .descriptorWriteArguments(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case state(Dev_Yanshouwang_BluetoothLowEnergy_BluetoothState)
    case startDiscoveryArguments(Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments)
    case discovery(Dev_Yanshouwang_BluetoothLowEnergy_Discovery)
    case connectArguments(Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments)
    case disconnectArguments(Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments)
    case connectionLost(Dev_Yanshouwang_BluetoothLowEnergy_GattConnectionLost)
    case characteristicReadArguments(Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments)
    case characteristicWriteArguments(Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments)
    case characteristicNotifyArguments(Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments)
    case characteristicValue(Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue)
    case descriptorReadArguments(Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments)
    case descriptorWriteArguments(Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments)

  #if !swift(>=4.1)
    static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_Message.OneOf_Value, rhs: Dev_Yanshouwang_BluetoothLowEnergy_Message.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.state, .state): return {
        guard case .state(let l) = lhs, case .state(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startDiscoveryArguments, .startDiscoveryArguments): return {
        guard case .startDiscoveryArguments(let l) = lhs, case .startDiscoveryArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discovery, .discovery): return {
        guard case .discovery(let l) = lhs, case .discovery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectArguments, .connectArguments): return {
        guard case .connectArguments(let l) = lhs, case .connectArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.disconnectArguments, .disconnectArguments): return {
        guard case .disconnectArguments(let l) = lhs, case .disconnectArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectionLost, .connectionLost): return {
        guard case .connectionLost(let l) = lhs, case .connectionLost(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.characteristicReadArguments, .characteristicReadArguments): return {
        guard case .characteristicReadArguments(let l) = lhs, case .characteristicReadArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.characteristicWriteArguments, .characteristicWriteArguments): return {
        guard case .characteristicWriteArguments(let l) = lhs, case .characteristicWriteArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.characteristicNotifyArguments, .characteristicNotifyArguments): return {
        guard case .characteristicNotifyArguments(let l) = lhs, case .characteristicNotifyArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.characteristicValue, .characteristicValue): return {
        guard case .characteristicValue(let l) = lhs, case .characteristicValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.descriptorReadArguments, .descriptorReadArguments): return {
        guard case .descriptorReadArguments(let l) = lhs, case .descriptorReadArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.descriptorWriteArguments, .descriptorWriteArguments): return {
        guard case .descriptorWriteArguments(let l) = lhs, case .descriptorWriteArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var services: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_Discovery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var rssi: Int32 = 0

  var advertisements: Data = Data()

  var connectable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GATT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var maximumWriteLength: Int32 = 0

  var services: [Dev_Yanshouwang_BluetoothLowEnergy_GattService] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var uuid: String = String()

  var characteristics: [Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var uuid: String = String()

  var canRead: Bool = false

  var canWrite: Bool = false

  var canWriteWithoutResponse: Bool = false

  var canNotify: Bool = false

  var descriptors: [Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattConnectionLost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gattKey: String = String()

  var serviceKey: String = String()

  var key: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gattKey: String = String()

  var serviceKey: String = String()

  var key: String = String()

  var value: Data = Data()

  var withoutResponse: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gattKey: String = String()

  var serviceKey: String = String()

  var key: String = String()

  var state: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gattKey: String = String()

  var serviceKey: String = String()

  var key: String = String()

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gattKey: String = String()

  var serviceKey: String = String()

  var characteristicKey: String = String()

  var key: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gattKey: String = String()

  var serviceKey: String = String()

  var characteristicKey: String = String()

  var key: String = String()

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "dev.yanshouwang.bluetooth_low_energy"

extension Dev_Yanshouwang_BluetoothLowEnergy_MessageCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLUETOOTH_STATE"),
    1: .same(proto: "CENTRAL_START_DISCOVERY"),
    2: .same(proto: "CENTRAL_STOP_DISCOVERY"),
    3: .same(proto: "CENTRAL_DISCOVERED"),
    4: .same(proto: "CENTRAL_CONNECT"),
    5: .same(proto: "GATT_DISCONNECT"),
    6: .same(proto: "GATT_CONNECTION_LOST"),
    7: .same(proto: "GATT_CHARACTERISTIC_READ"),
    8: .same(proto: "GATT_CHARACTERISTIC_WRITE"),
    9: .same(proto: "GATT_CHARACTERISTIC_NOTIFY"),
    10: .same(proto: "GATT_DESCRIPTOR_READ"),
    11: .same(proto: "GATT_DESCRIPTOR_WRITE"),
  ]
}

extension Dev_Yanshouwang_BluetoothLowEnergy_BluetoothState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSUPPORTED"),
    1: .same(proto: "POWERED_OFF"),
    2: .same(proto: "POWERED_ON"),
  ]
}

extension Dev_Yanshouwang_BluetoothLowEnergy_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "state"),
    3: .same(proto: "startDiscoveryArguments"),
    4: .same(proto: "discovery"),
    5: .same(proto: "connectArguments"),
    6: .same(proto: "disconnectArguments"),
    7: .same(proto: "connectionLost"),
    8: .same(proto: "characteristicReadArguments"),
    9: .same(proto: "characteristicWriteArguments"),
    10: .same(proto: "characteristicNotifyArguments"),
    11: .same(proto: "characteristicValue"),
    12: .same(proto: "descriptorReadArguments"),
    13: .same(proto: "descriptorWriteArguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 2: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_BluetoothState?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .state(v)
        }
      }()
      case 3: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .startDiscoveryArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .startDiscoveryArguments(v)
        }
      }()
      case 4: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_Discovery?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .discovery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .discovery(v)
        }
      }()
      case 5: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .connectArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .connectArguments(v)
        }
      }()
      case 6: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .disconnectArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .disconnectArguments(v)
        }
      }()
      case 7: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattConnectionLost?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .connectionLost(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .connectionLost(v)
        }
      }()
      case 8: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .characteristicReadArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .characteristicReadArguments(v)
        }
      }()
      case 9: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .characteristicWriteArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .characteristicWriteArguments(v)
        }
      }()
      case 10: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .characteristicNotifyArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .characteristicNotifyArguments(v)
        }
      }()
      case 11: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .characteristicValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .characteristicValue(v)
        }
      }()
      case 12: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .descriptorReadArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .descriptorReadArguments(v)
        }
      }()
      case 13: try {
        var v: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .descriptorWriteArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .descriptorWriteArguments(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .bluetoothState {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .state?: try {
      guard case .state(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .startDiscoveryArguments?: try {
      guard case .startDiscoveryArguments(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .discovery?: try {
      guard case .discovery(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .connectArguments?: try {
      guard case .connectArguments(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .disconnectArguments?: try {
      guard case .disconnectArguments(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .connectionLost?: try {
      guard case .connectionLost(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .characteristicReadArguments?: try {
      guard case .characteristicReadArguments(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .characteristicWriteArguments?: try {
      guard case .characteristicWriteArguments(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .characteristicNotifyArguments?: try {
      guard case .characteristicNotifyArguments(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .characteristicValue?: try {
      guard case .characteristicValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .descriptorReadArguments?: try {
      guard case .descriptorReadArguments(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .descriptorWriteArguments?: try {
      guard case .descriptorWriteArguments(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_Message, rhs: Dev_Yanshouwang_BluetoothLowEnergy_Message) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartDiscoveryArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.services.isEmpty {
      try visitor.visitRepeatedStringField(value: self.services, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_StartDiscoveryArguments) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_Discovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Discovery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "rssi"),
    3: .same(proto: "advertisements"),
    4: .same(proto: "connectable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.rssi) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.advertisements) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.connectable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.rssi != 0 {
      try visitor.visitSingularSInt32Field(value: self.rssi, fieldNumber: 2)
    }
    if !self.advertisements.isEmpty {
      try visitor.visitSingularBytesField(value: self.advertisements, fieldNumber: 3)
    }
    if self.connectable != false {
      try visitor.visitSingularBoolField(value: self.connectable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_Discovery, rhs: Dev_Yanshouwang_BluetoothLowEnergy_Discovery) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.advertisements != rhs.advertisements {return false}
    if lhs.connectable != rhs.connectable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_ConnectArguments) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GATT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GATT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "maximumWriteLength"),
    3: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maximumWriteLength) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.maximumWriteLength != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumWriteLength, fieldNumber: 2)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GATT, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GATT) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.maximumWriteLength != rhs.maximumWriteLength {return false}
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattService"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "uuid"),
    3: .same(proto: "characteristics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattService, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattService) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "uuid"),
    3: .same(proto: "canRead"),
    4: .same(proto: "canWrite"),
    5: .same(proto: "canWriteWithoutResponse"),
    6: .same(proto: "canNotify"),
    7: .same(proto: "descriptors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canRead) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.canWrite) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.canWriteWithoutResponse) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.canNotify) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.descriptors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    if self.canRead != false {
      try visitor.visitSingularBoolField(value: self.canRead, fieldNumber: 3)
    }
    if self.canWrite != false {
      try visitor.visitSingularBoolField(value: self.canWrite, fieldNumber: 4)
    }
    if self.canWriteWithoutResponse != false {
      try visitor.visitSingularBoolField(value: self.canWriteWithoutResponse, fieldNumber: 5)
    }
    if self.canNotify != false {
      try visitor.visitSingularBoolField(value: self.canNotify, fieldNumber: 6)
    }
    if !self.descriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptors, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristic) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.canRead != rhs.canRead {return false}
    if lhs.canWrite != rhs.canWrite {return false}
    if lhs.canWriteWithoutResponse != rhs.canWriteWithoutResponse {return false}
    if lhs.canNotify != rhs.canNotify {return false}
    if lhs.descriptors != rhs.descriptors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptor) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattDisconnectArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDisconnectArguments) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattConnectionLost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattConnectionLost"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattConnectionLost, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattConnectionLost) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristicReadArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gatt_key"),
    2: .standard(proto: "service_key"),
    3: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gattKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gattKey.isEmpty {
      try visitor.visitSingularStringField(value: self.gattKey, fieldNumber: 1)
    }
    if !self.serviceKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceKey, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicReadArguments) -> Bool {
    if lhs.gattKey != rhs.gattKey {return false}
    if lhs.serviceKey != rhs.serviceKey {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristicWriteArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gatt_key"),
    2: .standard(proto: "service_key"),
    3: .same(proto: "key"),
    4: .same(proto: "value"),
    5: .same(proto: "withoutResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gattKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.withoutResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gattKey.isEmpty {
      try visitor.visitSingularStringField(value: self.gattKey, fieldNumber: 1)
    }
    if !self.serviceKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceKey, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 4)
    }
    if self.withoutResponse != false {
      try visitor.visitSingularBoolField(value: self.withoutResponse, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicWriteArguments) -> Bool {
    if lhs.gattKey != rhs.gattKey {return false}
    if lhs.serviceKey != rhs.serviceKey {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.withoutResponse != rhs.withoutResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristicNotifyArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gatt_key"),
    2: .standard(proto: "service_key"),
    3: .same(proto: "key"),
    4: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gattKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gattKey.isEmpty {
      try visitor.visitSingularStringField(value: self.gattKey, fieldNumber: 1)
    }
    if !self.serviceKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceKey, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicNotifyArguments) -> Bool {
    if lhs.gattKey != rhs.gattKey {return false}
    if lhs.serviceKey != rhs.serviceKey {return false}
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattCharacteristicValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gatt_key"),
    2: .standard(proto: "service_key"),
    3: .same(proto: "key"),
    4: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gattKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gattKey.isEmpty {
      try visitor.visitSingularStringField(value: self.gattKey, fieldNumber: 1)
    }
    if !self.serviceKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceKey, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattCharacteristicValue) -> Bool {
    if lhs.gattKey != rhs.gattKey {return false}
    if lhs.serviceKey != rhs.serviceKey {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattDescriptorReadArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gatt_key"),
    2: .standard(proto: "service_key"),
    3: .standard(proto: "characteristic_key"),
    4: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gattKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.characteristicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gattKey.isEmpty {
      try visitor.visitSingularStringField(value: self.gattKey, fieldNumber: 1)
    }
    if !self.serviceKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceKey, fieldNumber: 2)
    }
    if !self.characteristicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.characteristicKey, fieldNumber: 3)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorReadArguments) -> Bool {
    if lhs.gattKey != rhs.gattKey {return false}
    if lhs.serviceKey != rhs.serviceKey {return false}
    if lhs.characteristicKey != rhs.characteristicKey {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GattDescriptorWriteArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gatt_key"),
    2: .standard(proto: "service_key"),
    3: .standard(proto: "characteristic_key"),
    4: .same(proto: "key"),
    5: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gattKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.characteristicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gattKey.isEmpty {
      try visitor.visitSingularStringField(value: self.gattKey, fieldNumber: 1)
    }
    if !self.serviceKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceKey, fieldNumber: 2)
    }
    if !self.characteristicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.characteristicKey, fieldNumber: 3)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments, rhs: Dev_Yanshouwang_BluetoothLowEnergy_GattDescriptorWriteArguments) -> Bool {
    if lhs.gattKey != rhs.gattKey {return false}
    if lhs.serviceKey != rhs.serviceKey {return false}
    if lhs.characteristicKey != rhs.characteristicKey {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
